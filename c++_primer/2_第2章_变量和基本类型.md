[TOC]

# 第2章_变量和基本类型

- 数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

---
## 2.1 基本内置类型

- 基本数据类型包括
  - 算数类型
    - 字符
    - 整数
    - 布尔值
    - 浮点数
  - 空类型(void)

### 2.1.1 算数类型

- 整型
  - 布尔型：bool
    - 取值要么是真（true），要么是假（false）
  - 字符型：
    - 基本字符型：char
      - 大小和一个机器字节一样
    - 拓展字符型：wchar_t，char16_t，char32_t
      - wchar_t 可以存放机器最大扩展字符集中的任意一个字符
      - char16_t 和 char32_t 则为 Unicode 字符集服务
  - 对于其他整型，C++ 规定
    - sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)
  - 注：
    - 除了布尔型和拓展字符型，其他整型可以用 signed 和 unsigned 区分带符号和不带符号两种
    - 对于基本字符型 char，分为 char、signed char、unsigned char 三种，char 会根据具体实现的差别，实际表现为 signed char 或 unsigned char
    - 无符号类型中的所有 bit 都用来存储值

- 浮点型
  - 单精度型：float
    - 大小一般为 32 bit
    - 精度一般为 7 个有效位
  - 双精度型：double
    - 大小一般为 64 bit
    - 精度一般为 16 个有效位
  - 拓展精度型：long double
    - 常常被用于有特殊浮点需求的硬件（具体实现不同则精度不同）

- 注：
  - C++ 标准只规定了各个数据类型的最小尺寸（编译器可以为这些类型赋予更大的尺寸）
  - 可寻址的最小内存块称为 `字节`
  - 存储的基本单元称为 `字`，通常由几个（4 或 8）字节组成
  - 为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型
    - 类型决定了数据所占的比特数以及如何解释这些比特内容


- **关于如何选择类型**
  - 当明确数值不可能为负数时，选用无符号类型
  - 使用 int 执行整数运算；如果超过 int 的范围，则使用 long long
  - 在算数表达式中不要使用 bool 和 char
  - 使用 char 的使用要明确使用 unsigned char 或 signed char
  - 浮点数运算使用 double

### 2.1.2 类型转换

- ==类型所能表示的值的范围决定了类型转换的过程
  1. `非布尔类型`赋值给`布尔类型`：若初始值为 0，则结果为 false；否则，结果为 true
  1. `布尔类型`赋值给`非布尔类型`：若初始值为 false，则结果为 0；否则，结果 1
  1. `浮点型`赋值给`整型`：仅保留浮点型的整数部分（直接舍弃小数部分）
  1. `整型`赋值给`浮点型`：浮点型的小数部分为 0，整数部分为整型的数值（整型的数值太大时可能损失精度）
  1. 赋值给`无符号类型`一个超过它表示范围的值：结果为初始值对无符号型表示数值的总数取模后的余数
      - 例如：把 -1 赋值给 unsigned char 的结果为 255（= -1 mod 256）
  1. 赋值给`带符号类型`一个超过它表示范围的值：结果**未定义**

- 注：==对于含有无符号类型的表达式==
  - 当一个算数表达式中既有无符号数又有 int 值时，那个 int 值会被转换为无符号数后再参与运算
  - 把负数转换为无符号数类似于直接给无符号数赋一个负值（即上面的第 5 条）
  - 当从无符号数中减去一个值时，不管这个值是不是无符号数，都必须确保结果不能是一个负值（即上面的第 5 条）

### 2.1.3 字面值常量

> 每个字面值常量都对应一种数据类型，字面常量的形式和值决定了它的数据类型。

- 整型字面值
  - 十进制：
    - 非 0 开头的整数
    - 默认带符号，取 int，long 和 long long 中尺寸最小且范围足够的那个
  - 八进制：以 0 开头的整数
    - 默认可能带也可能不带符号
    - 取 int，unsigned int，long，unsigned long，long long 和 unsigned long long 中尺寸最小且范围足够的那个
  - 十六进制：0x 或 0X 开头的整数
    - 默认可能带也可能不带符号
    - 取 int，unsigned int，long，unsigned long，long long 和 unsigned long long 中尺寸最小且范围足够的那个
  - 注：short 没有对应的字面值
- 浮点型字面值
  - 小数或科学计数法表示的指数
  - 默认为 double
- 字符字面值
  - 单引号括起来的一个字符
- 字符串字面值
  - 双引号括起来的一个或多个字符
  - 以空字符 `\0` 结尾
  - 注：如果==两个字符串字面值==位置紧邻且仅由空格、缩进和换行符分隔，则它们==实际上是一个整体==
- 转义序列：不可打印或具有特殊含义的序列，被当做==一个字符==使用
  - 以反斜杠 `\` 开始
  - 转移序列的泛化形式
    - `\` 后紧跟 1、2 或 3 个八进制数字（超过 3 个的数字不再属于转移序列）
    - `\x` 后跟多个数字（所有数字都属于转移序列）
- **指定字面值的类型**
  | 位置 | 符号 | 含义 | 类型 | 适用范围 | 示例 |
  | :---: | :---: | :---: | :---: | :---: | :---: |
  | 前缀 | u | Unicode 16 字符 | char16_t | 字符和字符串 | u'a' |
  | ^   | U | Unicode 32 字符 | char32_t | ^ | U"abc" |
  | ^   | L | 宽字符 | wchar_t | ^ | L'a' |
  | ^   | u8 | UTF-8 | char | 字符串 | u8"hello" |
  | 后缀 | u or U | unsigned | unsigned int，unsigned long，unsigned long long | 整型 | 110u |
  | ^    | l or L | > | long | ^ | 110L |
  | ^    | ll or LL | > | long long | ^ | 110LL |
  | ^    | f or F | > | float | 浮点型 | 3.14F |
  | ^    | l or L | > | long double | ^ | 3.14L | 
- 布尔型字面值：==true 和 false==
- 指针型字面值：==nullptr==

---
## 2.2 变量

- 变量的数据类型决定了
  - 所占内存空间的大小和布局方式
  - 能存储的值的范围
  - 能参与的运算

### 2.2.1 变量定义

- 变量定义的基本形式
  - 类型说明符 + 变量名（一个或多个，逗号分隔）+ 分号
  - 期间可以为一个或多个变量赋初值
  - 在同一条定义语句中（分号分隔语句），可以用先定义的变量值去初始化后定义的其他变量

- ==C++ 中初始化和赋值是两个完全不同的操作==

- 列表初始化
  - 基本形式：用花括号来初始化变量
  - 适用场景：
    - 初始化对象
    - 为对象赋新值
  - 重要特点：
    - 对内置类型，如果使用列表初始化且初始值存在丢失信息的风险，则编译器报错（可以理解为不进行隐式转换）
      ```C++
        long double ld = 3.1415926536
        int a{ld}, b = {ld};  // 错误：由于存在丢失信息的风险，不执行转换
        int c(ld), d = ld;  // 正确：虽然丢失了部分信息（精度），但确实执行转换
      ```

- 默认初始化
  - 触发条件：定义变量时没有指定初值
  - 影响默认值的因素：
    - 变量的类型
    - 定义变量的位置
  - 内置类型，由定义变量的位置决定
    - 定义在函数体之外的变量，初始化为 0
    - 定义在函数体之内的变量，不被初始化（值未定义）
  - 类类型，由各个类自行决定

- ==对象==：指的是具有某种数据类型的内存空间

### 2.2.2 变量声明和定义的关系

- C++ 语言支持分离式编译
  - 允许将程序分割为若干个文件
  - 每个文件可以被独立==编译==

- 为了支持分离式编译，C++ 语言将==声明==和==定义==区分开来
  - 声明：
    - 使得名字为程序所知（一个文件如果想要使用==别处定义==的名字，则必须包含对那个名字的声明）
    - 规定了变量的类型和名字
    - 使用 `extern` 关键字声明变量（不要显式地初始化变量，否则会变为定义） 
  - 定义：
    - 负责创建与名字关联的实体
    - 不仅规定了变量的类型和名字，还要申请存储空间，也可能需要给变量赋初值

- ==变量能且仅能被定义一次，但可以被多次声明==

### 2.2.3 标识符

- C++ 标识符
  - 由字母、数字和下划线组成
  - 必须以字母或下划线开头
  - 没有长度限制
  - 大小写敏感

- C++ 标准库保留名字（用户自定义标识符不能使用以下形式）
  - 连续出现两个下划线
  - 以下划线紧连大写字母开头
  - 函数体外的标识符以下划线开头

- C++ 关键字（不能作为标识符）
  1. **alignas**
  1. **alignof**
  1. asm
  1. auto
  1. bool
  1. break
  1. case
  1. catch
  1. char
  1. char16_t
  1. char32_t
  1. class
  1. const
  1. constexpr
  1. const_cast
  1. continue
  1. decltype
  1. default
  1. delete
  1. do
  1. double
  1. dynamic_cast
  1. else
  1. enum
  1. explicit
  1. export
  1. extern
  1. false
  1. float
  1. for
  1. friend
  1. goto
  1. if
  1. inline
  1. int
  1. long
  1. mutable
  1. namespace
  1. new
  1. noexcept
  1. nullptr
  1. operator
  1. private
  1. protected
  1. public
  1. register
  1. **reinterpret_cast**
  1. return
  1. short
  1. signed
  1. sizeof
  1. static
  1. **static_assert**
  1. static_cast
  1. struct
  1. switch
  1. template
  1. this
  1. **thread_local**
  1. throw
  1. true
  1. try
  1. typedef
  1. **typeid**
  1. typename
  1. union
  1. unsigned
  1. using
  1. virtual
  1. void
  1. volatile
  1. wchar_t
  1. while

- C++ 操作符替代名
  1. and
  1. bitand
  1. compl
  1. not_eq
  1. or_eq
  1. xor_eq
  1. and_eq
  1. bitor
  1. not
  1. or
  1. xor

- 命名规范
  - 标识符体现实际含义
  - ==变量名==用小写字母
  - ==自定义类名==用大写字母
  - 单词间有明显区分（下划线或驼峰）

### 2.2.4 名字的作用域

- 背景：出现在程序中不同位置的同一个名字（标识符），可能代表的是不同的实体
- 作用域：==C++ 语言中大多数作用域都以花括号分隔==
  - 分类：
    - 全局作用域：其中的名字在整个程序范围内可用
    - 块作用域：其中的名字仅在当前块内可用
  - 建议：当第一次使用变量时才定义该变量
- 作用域的嵌套
  - 外层作用域：包含着其它作用域的作用域
  - 内层作用域：被其它作用域包含着的作用域
  - 注意：
    - 内层作用域可以访问外层作用域中的名字（反之不行）
    - 如果内层作用域中的定义了与外层作用域中相同的名字，将覆盖外层作用域中对应的名字（直到内层作用域结束）
  - 建议：如果函数有可能用到某个全局变量，那么就不宜在函数内再定义个同名的局部变量
- 名字的有效区域
  - 始于：名字的声明语句
  - 止于：声明语句所在作用域的末端

---
## 2.3 复合类型

- 复合类型：指的是基于其他类型定义的类型
- C++ 语言中的复合类型（其中两种）
  - 引用
  - 指针

### 2.3.1 引用

- ==本质：已存在对象的别名==
- 定义方式示例：
  ```C++
    int ival = 1024;
    int &refVal = ival;
  ```
- 注意：
  - 引用在定义时必须初始化（因为无法令引用重新绑定到另一个对象上）
  - 不能定义引用的引用（因为引用本身不是一个对象）
    - 也就不能定义指向引用的指针
  - 引用只能绑定在对象上（不能绑定字面值、表达式的计算结果）

### 2.3.2 指针

- 指针与引用的异同：
  - 相同：
    - 间接访问对象
  - 不同：
    - 指针本身是对象（允许多次赋值和拷贝）
    - 指针无需在定义时赋值（相当于没有初始化，其值不确定）

- 使用方式示例：
  ```C++
    int val = 1024;
    int *p1;  // 不指定初值
    int *p2 = &val;  // 取 val 的地址作为 p2 的初值
    int *p3 = p2;  // 使用 p2 的值作为 p3 的初值

    int *p4 = nullptr;  // C++11 新标准，建议用法
    int *p5 = 0;
    int *p6 = NULL;

    cout << *p2 << endl;  // 解引用指针 p2，得到指针所指的对象的内容
    cout << *p3 << endl;
  ```

- 指针的值（4 种情况）
  1. 一个对象的地址
  1. 紧邻对象所占空间的下一个位置的地址
  1. 空指针
  1. 无效指针

- 赋值和指针
  - 赋值操作改变的永远是等号左侧的==对象==
  - 解引用操作的==结果==是得到指针所指的==对象==
  - 示例
    ```C++
    int val = 1024;
    int *p;
    p = &val;  // 修改指针对象的值
    *p = 2048;  // 修改指针所指对象的值
    ```

- 其他指针操作
  - 条件表达式中：指针的值为 0，则条件为 false；否则，为 true
  - 比较操作：如果两个指针指向相同的地址，则两指针相等；否则，不相等

- void* 指针：可以存放任意对象的地址（但不能操作所指对象，因为无法理解内存布局）
  - 用途：
    - 与别的指针比较
    - 作为函数的输入、输出
    - 赋值给另一个 void* 指针

- 建议：
  - 初始化所有的指针（包括使用 nullptr 进行初始化）

- 注意：
  - 指针的类型和它所指对象的类型要严格匹配（除 2.4.2 和 15.2.3 所述的例外）
  - 访问无效指针的值将引发错误（编译器不负责检查此类错误）
  - 解引用操作仅适用于确实指向了某个对象的有效指针

### 2.3.3 理解复合类型的声明

- 同一条定义语句中，基本数据类型只能有一个，但类型修饰符可以有多个
  - 类型修饰符（`*` 和 `&`）只作用当前变量，而不是整条声明语句
  - 示例：
    ```C++
    int i = 2014, *p = &i, &r = i;
    ```
  
- 指向指针的指针：类型修饰符的个数没有限制
  - 示例：
    ```C++
    int val = 1024;
    int *p = &val;  // 一级指针
    int **p = &p;  // 二级指针
    
    cout << *p << **p  << endl;
    ```

- 指向指针的引用（不能存在指向引用的指针）
  - 示例：
    ```C++
    int val = 1024;
    int *p = &val;
    int *&r = p;  // 从右往左阅读，有利于弄清其真实含义
    ```
  - 建议：
    - 当面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清其真实含义

---
## 2.4 const限定符

- const 对象
  - 一旦创建后其值就不能再改变（所以 const 对象必须在声明时定义）
  - 可以使用任意表达式初始化 const 对象的值
  - 初始化 const 对象时，实际上是拷贝的原来对象的值，一旦拷贝完成，新的对象就和原来的对象没有关系了
  - 示例
    ```C++
    int val = 1024;
    const int cVal = val;
    int val2 = cVal;
    ```

- 默认状态下，const 对象仅在当前文件内有效
  - 在定义和引用常量时使用 extern 关键字可以将有效范围拓展到多个指定文件
  - 示例
    ```C++
    // 文件1
    extern const int val = 1024;  // 定义一个常量，该常量可以在其它文件访问到

    // 文件2
    extern const int val;  // 使用的是文件1中定义的同一个常量
    ```

### 2.4.1 const的引用

- 常量引用：
  - 不能通过常量引用修改它所绑定的对象
  - 不能把普通引用绑定到常量上
  - 引用的类型必须与其所引用对象的类型一致，但有两个例外
    1. 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用类型即可（实际引用的是临时量）
  - 常量引用仅对引用可参与的操作做出限定（不能通过该引用修改被引用的对象），而对于被引用的对象是不是一个常量不作限定
  - 示例
    ```C++
    const int val = 1024;
    const int &rVal = val;

    rVal = 2048;  // 错误：rVal 是对常量的引用
    int &rVal2 = val;  // 错误：试图把非常量引用绑定到常量

    const int &rVal3 = val * 3;
    // 等价于
    const int temp = val * 3;
    const &rVal3 = temp;
    ```

### 2.4.2 指针和const

- 指向常量的指针
  - 不能通过该指针修改它所指向的对象
  - 指针的类型必须与其所指的对象的类型一致，但有两个例外
    1. 允许一个指向常量的指针指向一个非常量对象
  - 指向常量的指针仅对该指针可参与的操作做出限定（不能通过该指针修改其所指的对象，但可以重新指向其他对象），而对于被指向的对象是不是一个常量不作限定
  - 示例
    ```C++
    const int val = 1024;

    int *p = &val;  // 错误：普通指针不能指向常量对象
    const int *p2 = &val;  // 正确
    *p2 = 2048;  // 错误：不能通过指向常量的指针修改所指对象的值
    ```

- const 指针：把指针本身定位常量（不能修改所指的对象）
  - 原理：指针是对象（而引用不是）
  - 注意：必须在定义时完成初始化
  - 示例
    ```C++
    int val = 1024;
    const int val2 = 2048;

    int * const p = &val;  // 正确
    const int * const p2 = &val2;  // 正确
    ```

### 2.4.3 顶层const与底层const

> 指针本身是不是常量，以及指针所指的是不是一个常量对象，是两个相互独立的问题

- 分类：
  - 顶层 const：表示指针（或对象）本身是个常量
  - 底层 const：表示指针所指的对象是个常量
- 作用：防止非法的数据更改
  - 如果对象仅是顶层 const，那么可以无限制拷贝对象的值
  - 拷入、拷出对象必须拥有相同的底层 const
  - 引用类型的底层 const 需要与被引用对象的顶层 const 相同
    - 引用类型没有顶层 const
- 示例
  ```C++
  int val1 = 1024;
  const int val2 = 2048;  // val2 为顶层 const

  int * const p1 = &val1;  // p1 为顶层 const
  const int * p2 = &val2;  // p2 为底层 const
  const int * const p3 = &val2;  // p3 既是顶层 const，也是底层 const

  int *p4 = p3;  // 错误：p3是包含底层 const
  p2 = p3;  // 正确
  p2 = &val1;  // 正确
  int &rVal = val2;  // 错误：普通引用不能绑定到常量上
  const int &rVal2 = val2;  // 正确
  ```

### 2.4.4 constexpr和常量表达式

- 常量表达式：
  - 定义：使用 `constexpr` 关键字声明变量（C++11 新标准）
    - 仅仅是要求编译器==验证变量==是否是一个常量表达式
  - 特点：
    - 值不会改变
    - ==编译过程就能得到计算结果==
  - 构造方法：
    - 使用==字面值==定义变量
    - 使用==常量表达式==定义变量
- 指针和常量表达式：指向固定内存地址的指针可以声明为 `constexpr` 类型（与所指对象无关）
  - nullptr 或 0 指针
  - 函数体外定义的对象的指针
  - 函数体内定义的、有效范围超过函数体本身的对象的指针
- 建议：如果认定一个变量是常量表达式，那就把它声明为 `constexpr` 类型（有助于编译器进行优化）
- 注意：constexpr 把它所定义的对象置为了顶层 const（不要与普通变量的顶层、底层const弄混，应该参考 typedef 的理解方式）
- 示例
  ```C++
  int val1 = 1024;

  constexpr int val2 = 2048;
  constexpr int * p1 = nullptr;  // 这里 p1 是顶层 const
  constexpr int * p2 = &val1;  // 这里 p2 是顶层 const
  constexpr const int * p3 = &val2;  // 这里 p3 是顶层和底层 const
  ```

---
## 2.5 处理类型

### 2.5.1 类型别名

- 本质：类型的同义词（与类型的名字是等价）
- 定义方法
  - 传统方法：使用 typedef 关键字
  - 新标准方法：使用别名声明
  - 示例
    ```C++
    // 传统方法
    typedef double wages;  // wages 等价于 double
    type wages base, *p;  // base 等价于 double，p 等价于 double *

    // C++11新标准（与上面等价的定义）
    using wages = double;  
    using base = wages;
    using p = wages *;
    ```

- 指针、常量和类型别名
  - 示例
    ```C++
    typedef char * pstring;
    const pstring cstr = 0;  // cstr 是指向固定内存地址的指针
    const pstring *ps;  // cstr 是指针，无法通过该指针改变所指对象的值，而所指的对象是 char *
    ```

- 注意：
  - 把类型别名当成一个整体（一个完整的新的类型）来看
  - 简单的把类型别名替换成本来的样子是错误的

### 2.5.2 auto类型说明符

- 作用：让==编译器==根据变量的初始值来自动分析表达式所属的类型
- 注意：
  1. 变量必须有初始值（声明时定义）
  1. 可以声明多个变量，但所有变量的初始基本数据类型必须一致
  1. 如果声明多个变量，符号 `&` 和 `*` 只从属于某个声明符
  1. 如果初始值为某个对象的引用，则变量的类型为该对象的类型（而不是引用）
  1. 默认情况下，auto 忽略顶层 const，保留底层 const
  1. 可以通过明确指出声明顶层 const
  1. 可以将引用的类型设定为 auto
- 示例
  ```C++
  // auto 进行类型推断时，也要确保数据安全
  // 对于拷贝操作，直接忽略顶层 const
  // 对于引用和指针，则要考虑所指对象的安全
  auto val1;  // 错误：必须有初值
  
  auto val2 = 0, pi = 3.14;  // 错误：多个变量的基本数据类型必须一致
  auto val3 = 0, &rVal3 = val3, *pVal3 = &val3;  // 正确

  const int val4 = 0, &rVal4 = val4;
  int val5 = 0;
  auto b = val4;  // 正确：b 是一个整数，值为 val4 的拷贝
  auto c = rVal4;  // 正确：c 是一个整数，值为 val4 的拷贝
  auto d = &val5;  // 正确：d 是一个指向 val5 的指针
  auto e = &val4;  // 正确：e 是一个指向 val4 的常量指针（不能通过该指针修改 val4 的值）

  const auto f = val4;  // 正确：f 是一个整型常量，值为 val4 的拷贝

  auto &g = val4;  // 正确：g 是一个整型常量引用（绑定到 val4，无法通过 g 修改 val4 的值）
  auto &h = 42;  // 错误：不能为非常量引用绑定字面值
  const auto &i = 42;  // 正确：可以为常量引用绑定字面值
  ```

- 备注：本质上就是通过 auto 声明变量的几种操作方式，并且保证 const 的操作限制

### 2.5.3 decltype类型指示符

- 作用：从==表达式==的类型推断出要定义的变量的类型，但是不想用该表达式的值对变量进行初始化
- 注意：
  - 编译器不会实际执行该表达式（例如，如果表达式是函数，是不会调用该函数的）
  - 如果表达式是一个变量，则返回该变量的类型（包括顶层 const 和引用）
    - 引用从来都是其所绑定对象的同义词，除了 decltype 场景下
  - 如果表达式不是一个变量，则返回表达式结果对应的类型
  - 如果表达式是解引用操作，则返回对应的引用类型（因为解引用操作的结果是指针实际所指的对象，可以用来修改该对象的值）
  - 如果表达式是一个加上括号的变量，则返回该变量的引用类型
- 示例
  ```C++
  const int val = 1024, &rVal = val, *pVal = &val;

  decltype(val) a = 0;  // a 的类型是 const int
  decltype(rVal) b = a;  // b 的类型是 const int &
  decltype(rVal) c;  // 错误：c 是引用类型，必须初始化

  decltype(*pVal) d = a;  // d 的类型是 const int &
  decltype(rVal + 0) e;  // e 的类型是 int

  decltype((val)) f = a;  // f 的类型是 const int &
  ```

---
## 2.6 自定义数据结构

- 数据结构是把一组相关的数据元素组织起来，然后使用它们的策略和方法
- C++ 语言允许用户以==类==的形式自定义数据类型

### 2.6.1 定义Sale_data类型

- 关键字：`struct` 或 `class`
- 一般形式：`struct { 成员1; 成员2; ...};`
- 数据成员
  - 定义方法与普通变量一致
  - 可以为数据成员提供一个==类内初始值==（C++11新标准）
  - > 类的==各个对象==之间的数据成员是相互独立的
- 示例
  ```C++
  struct Sale_data
  {
    std::string bookNo;
    unsigned units_sold{0};
    double revenue = 0.0;
  } accum, *pAccum;  // accum Sale_data 类型的对象，pAccum 是 Sale_data 类型的指针

  Sale_data accum2, *pAccum2;  // 与前面相对应
  ```

### 2.6.2 使用Sale_data类

TODO: 与 C++98 基本一致，暂略

### 2.6.3 编写自己的头文件

TODO: 与 C++98 基本一致，暂略