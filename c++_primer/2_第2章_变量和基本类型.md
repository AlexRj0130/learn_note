[TOC]

# 第2章_变量和基本类型

- 数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

---
## 2.1 基本内置类型

- 基本数据类型包括
  - 算数类型
    - 字符
    - 整数
    - 布尔值
    - 浮点数
  - 空类型(void)

### 2.1.1 算数类型

- 整型
  - 布尔型：bool
    - 取值要么是真（true），要么是假（false）
  - 字符型：
    - 基本字符型：char
      - 大小和一个机器字节一样
    - 拓展字符型：wchar_t，char16_t，char32_t
      - wchar_t 可以存放机器最大扩展字符集中的任意一个字符
      - char16_t 和 char32_t 则为 Unicode 字符集服务
  - 对于其他整型，C++ 规定
    - sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)
  - 注：
    - 除了布尔型和拓展字符型，其他整型可以用 signed 和 unsigned 区分带符号和不带符号两种
    - 对于基本字符型 char，分为 char、signed char、unsigned char 三种，char 会根据具体实现的差别，实际表现为 signed char 或 unsigned char
    - 无符号类型中的所有 bit 都用来存储值

- 浮点型
  - 单精度型：float
    - 大小一般为 32 bit
    - 精度一般为 7 个有效位
  - 双精度型：double
    - 大小一般为 64 bit
    - 精度一般为 16 个有效位
  - 拓展精度型：long double
    - 常常被用于有特殊浮点需求的硬件（具体实现不同则精度不同）

- 注：
  - C++ 标准只规定了各个数据类型的最小尺寸（编译器可以为这些类型赋予更大的尺寸）
  - 可寻址的最小内存块称为 `字节`
  - 存储的基本单元称为 `字`，通常由几个（4 或 8）字节组成
  - 为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型
    - 类型决定了数据所占的比特数以及如何解释这些比特内容


- **关于如何选择类型**
  - 当明确数值不可能为负数时，选用无符号类型
  - 使用 int 执行整数运算；如果超过 int 的范围，则使用 long long
  - 在算数表达式中不要使用 bool 和 char
  - 使用 char 的使用要明确使用 unsigned char 或 signed char
  - 浮点数运算使用 double

### 2.1.2 类型转换

- ==类型所能表示的值的范围决定了类型转换的过程
  1. `非布尔类型`赋值给`布尔类型`：若初始值为 0，则结果为 false；否则，结果为 true
  1. `布尔类型`赋值给`非布尔类型`：若初始值为 false，则结果为 0；否则，结果 1
  1. `浮点型`赋值给`整型`：仅保留浮点型的整数部分（直接舍弃小数部分）
  1. `整型`赋值给`浮点型`：浮点型的小数部分为 0，整数部分为整型的数值（整型的数值太大时可能损失精度）
  1. 赋值给`无符号类型`一个超过它表示范围的值：结果为初始值对无符号型表示数值的总数取模后的余数
    - 例如：把 -1 赋值给 unsigned char 的结果为 255（= -1 mod 256）
  1. 赋值给`带符号类型`一个超过它表示范围的值：结果**未定义**

- 注：==对于含有无符号类型的表达式==
  - 当一个算数表达式中既有无符号数又有 int 值时，那个 int 值会被转换为无符号数后再参与运算
  - 把负数转换为无符号数类似于直接给无符号数赋一个负值（即上面的第 5 条）
  - 当从无符号数中减去一个值时，不管这个值是不是无符号数，都必须确保结果不能是一个负值（即上面的第 5 条）

### 2.1.3 字面值常量

> 每个字面值常量都对应一种数据类型，字面常量的形式和值决定了它的数据类型。

- 整型字面值
  - 十进制：
    - 非 0 开头的整数
    - 默认带符号，取 int，long 和 long long 中尺寸最小且范围足够的那个
  - 八进制：以 0 开头的整数
    - 默认可能带也可能不带符号
    - 取 int，unsigned int，long，unsigned long，long long 和 unsigned long long 中尺寸最小且范围足够的那个
  - 十六进制：0x 或 0X 开头的整数
    - 默认可能带也可能不带符号
    - 取 int，unsigned int，long，unsigned long，long long 和 unsigned long long 中尺寸最小且范围足够的那个
  - 注：short 没有对应的字面值
- 浮点型字面值
  - 小数或科学计数法表示的指数
  - 默认为 double
- 字符字面值
  - 单引号括起来的一个字符
- 字符串字面值
  - 双引号括起来的一个或多个字符
  - 以空字符 `\0` 结尾
  - 注：如果==两个字符串字面值==位置紧邻且仅由空格、缩进和换行符分隔，则它们==实际上是一个整体==
- 转义序列：不可打印或具有特殊含义的序列，被当做==一个字符==使用
  - 以反斜杠 `\` 开始
  - 转移序列的泛化形式
    - `\` 后紧跟 1、2 或 3 个八进制数字（超过 3 个的数字不再属于转移序列）
    - `\x` 后跟多个数字（所有数字都属于转移序列）
- **指定字面值的类型**
  | 位置 | 符号 | 含义 | 类型 | 适用范围 | 示例 |
  | :---: | :---: | :---: | :---: | :---: | :---: |
  | 前缀 | u | Unicode 16 字符 | char16_t | 字符和字符串 | u'a' |
  | ^   | U | Unicode 32 字符 | char32_t | ^ | U"abc" |
  | ^   | L | 宽字符 | wchar_t | ^ | L'a' |
  | ^   | u8 | UTF-8 | char | 字符串 | u8"hello" |
  | 后缀 | u or U | unsigned | unsigned int，unsigned long，unsigned long long | 整型 | 110u |
  | ^    | l or L | > | long | ^ | 110L |
  | ^    | ll or LL | > | long long | ^ | 110LL |
  | ^    | f or F | > | float | 浮点型 | 3.14F |
  | ^    | l or L | > | long double | ^ | 3.14L | 
- 布尔型字面值：==true 和 false==
- 指针型字面值：==nullptr==

---
## 2.2 变量

- 变量的数据类型决定了
  - 所占内存空间的大小和布局方式
  - 能存储的值的范围
  - 能参与的运算

### 2.2.1 变量定义

- 变量定义的基本形式
  - 类型说明符 + 变量名（一个或多个，逗号分隔）+ 分号
  - 期间可以为一个或多个变量赋初值
  - 在同一条定义语句中（分号分隔语句），可以用先定义的变量值去初始化后定义的其他变量

- ==C++ 中初始化和赋值是两个完全不同的操作==

- 列表初始化
  - 基本形式：用花括号来初始化变量
  - 适用场景：
    - 初始化对象
    - 为对象赋新值
  - 重要特点：
    - 对内置类型，如果使用列表初始化且初始值存在丢失信息的风险，则编译器报错（可以理解为不进行隐式转换）
      ```C++
        long double ld = 3.1415926536
        int a{ld}, b = {ld};  // 错误：由于存在丢失信息的风险，不执行转换
        int c(ld), d = ld;  // 正确：虽然丢失了部分信息（精度），但确实执行转换
      ```

- 默认初始化
  - 触发条件：定义变量时没有指定初值
  - 影响默认值的因素：
    - 变量的类型
    - 定义变量的位置
  - 内置类型，由定义变量的位置决定
    - 定义在函数体之外的变量，初始化为 0
    - 定义在函数体之内的变量，不被初始化（值未定义）
  - 类类型，由各个类自行决定

- ==对象==：指的是具有某种数据类型的内存空间

### 2.2.2 变量声明和定义的关系

- C++ 语言支持分离式编译
  - 允许将程序分割为若干个文件
  - 每个文件可以被独立==编译==

- 为了支持分离式编译，C++ 语言将==声明==和==定义==区分开来
  - 声明：
    - 使得名字为程序所知（一个文件如果想要使用==别处定义==的名字，则必须包含对那个名字的声明）
    - 规定了变量的类型和名字
    - 使用 `extern` 关键字声明变量（不要显式地初始化变量，否则会变为定义） 
  - 定义：
    - 负责创建与名字关联的实体
    - 不仅规定了变量的类型和名字，还要申请存储空间，也可能需要给变量赋初值

- ==变量能且仅能被定义一次，但可以被多次声明==

### 2.2.3 标识符

- C++ 标识符
  - 由字母、数字和下划线组成
  - 必须以字母或下划线开头
  - 没有长度限制
  - 大小写敏感

- C++ 标准库保留名字（用户自定义标识符不能使用以下形式）
  - 连续出现两个下划线
  - 以下划线紧连大写字母开头
  - 函数体外的标识符以下划线开头

- C++ 关键字（不能作为标识符）
  1. alignas
  1. alignof
  1. asm
  1. auto
  1. bool
  1. break
  1. case
  1. catch
  1. char
  1. char16_t
  1. char32_t
  1. class
  1. const
  1. constexpr
  1. const_cast
  1. continue
  1. decltype
  1. default
  1. delete
  1. do
  1. double
  1. dynamic_cast
  1. else
  1. enum
  1. explicit
  1. export
  1. extern
  1. false
  1. float
  1. for
  1. friend
  1. goto
  1. if
  1. inline
  1. int
  1. long
  1. mutable
  1. namespace
  1. new
  1. noexcept
  1. nullptr
  1. operator
  1. private
  1. protected
  1. public
  1. register
  1. reinterpret_cast
  1. return
  1. short
  1. signed
  1. sizeof
  1. static
  1. static_assert
  1. static_cast
  1. struct
  1. switch
  1. template
  1. this
  1. thread_local
  1. throw
  1. true
  1. try
  1. typedef
  1. typeid
  1. typename
  1. union
  1. unsigned
  1. using
  1. virtual
  1. void
  1. volatile
  1. wchar_t
  1. while

- C++ 操作符替代名
  1. and
  1. bitand
  1. compl
  1. not_eq
  1. or_eq
  1. xor_eq
  1. and_eq
  1. bitor
  1. not
  1. or
  1. xor

- 命名规范
  - 标识符体现实际含义
  - ==变量名==用小写字母
  - ==自定义类名==用大写字母
  - 单词间有明显区分（下划线或驼峰）

### 2.2.4 名字的作用域

- 背景：出现在程序中不同位置的同一个名字（标识符），可能代表的是不同的实体
- 作用域：C++ 语言中大多数作用域都以花括号分隔
  - 分类：
    - 全局作用域：其中的名字在整个程序范围内可用
    - 块作用域：其中的名字仅在当前块内可用
  - 建议：当第一次使用变量时才定义该变量
- 作用域的嵌套
  - 外层作用域：包含着其它作用域的作用域
  - 内层作用域：被其它作用域包含着的作用域
  - 注意：
    - 内层作用域可以访问外层作用域中的名字（反之不行）
    - 如果内层作用域中的定义了与外层作用域中相同的名字，将覆盖外层作用域中对应的名字（直到内层作用域结束）
  - 建议：如果函数有可能用到某个全局变量，那么就不宜在函数内再定义个同名的局部变量
- 名字的有效区域
  - 始于：名字的声明语句
  - 止于：声明语句所在作用域的末端

---
## 2.3 复合类型

- 复合类型：指的是基于其他类型定义的类型
- C++ 语言中的复合类型（其中两种）
  - 引用
  - 指针

### 2.3.1 引用

- ==本质：已存在对象的别名==
- 定义方式示例：
  ```C++
    int ival = 1024;
    int &refVal = ival;
  ```
- 注意：
  - 引用在定义时必须初始化（因为无法令引用重新绑定到另一个对象上）
  - 不能定义引用的引用（因为引用本身不是一个对象）
    - 也就不能定义指向引用的指针
  - 引用只能绑定在对象上（不能绑定字面值、表达式的计算结果）

### 2.3.2 指针

- 指针与引用的异同：
  - 相同：
    - 间接访问对象
  - 不同：
    - 指针本身是对象（允许多次赋值和拷贝）
    - 指针无需在定义时赋值（相当于没有初始化，其值不确定）

- 使用方式示例：
  ```C++
    int val = 1024;
    int *p1;  // 不指定初值
    int *p2 = &val;  // 取 val 的地址作为 p2 的初值
    int *p3 = p2;  // 使用 p2 的值作为 p3 的初值

    int *p4 = nullptr;  // C++11 新标准，建议用法
    int *p5 = 0;
    int *p6 = NULL;

    cout << *p2 << endl;  // 解引用指针 p2，得到指针所指的对象的内容
    cout << *p3 << endl;
  ```

- 指针的值（4 种情况）
  1. 一个对象的地址
  1. 紧邻对象所占空间的下一个位置的地址
  1. 空指针
  1. 无效指针

- 赋值和指针
  - 赋值操作改变的永远是等号左侧的==对象==
  - 解引用操作的==结果==是得到指针所指的==对象==
  - 示例
    ```C++
    int val = 1024;
    int *p;
    p = &val;  // 修改指针对象的值
    *p = 2048;  // 修改指针所指对象的值
    ```

- 其他指针操作
  - 条件表达式中：指针的值为 0，则条件为 false；否则，为 true
  - 比较操作：如果两个指针指向相同的地址，则两指针相等；否则，不相等

- void* 指针：可以存放任意对象的地址（但不能操作所指对象，因为无法理解内存布局）
  - 用途：
    - 与别的指针比较
    - 作为函数的输入、输出
    - 赋值给另一个 void* 指针

- 建议：
  - 初始化所有的指针（包括使用 nullptr 进行初始化）

- 注意：
  - 指针的类型和它所指对象的类型要严格匹配（除 2.4.2 和 15.2.3 所述的例外）
  - 访问无效指针的值将引发错误（编译器不负责检查此类错误）
  - 解引用操作仅适用于确实指向了某个对象的有效指针

### 2.3.3 理解复合类型的声明

- 同一条定义语句中，基本数据类型只能有一个，但类型修饰符可以有多个
  - 类型修饰符（`*` 和 `&`）只作用当前变量，而不是整条声明语句
  - 示例：
    ```C++
    int i = 2014, *p = &i, &r = i;
    ```
  
- 指向指针的指针：类型修饰符的个数没有限制
  - 示例：
    ```C++
    int val = 1024;
    int *p = &val;  // 一级指针
    int **p = &p;  // 二级指针
    
    cout << *p << **p  << endl;
    ```

- 指向指针的引用（不能存在指向引用的指针）
  - 示例：
    ```C++
    int val = 1024;
    int *p = &val;
    int *&r = p;  // 从右往左阅读，有利于弄清其真实含义
    ```
  - 建议：
    - 当面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清其真实含义

---
## 2.4 const限定符

---
## 2.5 处理类型

---
## 2.6 自定义数据结构