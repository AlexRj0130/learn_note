[TOC]

# 第3章_字符串_向量和数组

- string: 可变长字符串
- vector: 可变长集合

- 备注
  - 内置类型由 C++ 语言直接定义，体现了大多数计算机硬件本身具备的能力
  - 数组的实现与硬件密切相关，因此与标准库 string 和 vector 相比，灵活性上稍显不足

---
## 3.1_命名空间using声明

- 作用域操作符 `::`
- `using` 声明
  - 一般形式：using namespace::name;
  - 示例：using std::cin;
- 备注
  - 每个名字都需要独立的 using 声明（以分号结束）
  - 头文件不应包含 using 声明

---
## 3.2_标准库类型string

- string: 可变长的字符序列
- 头文件：\<string>
- 命名空间：std
- 备注：对于==一般应用场合==来说，有足够的效率

### 3.2.1 定义和初始化string对象

- 直接初始化
  - 不使用等号 `=` 初始化一个变量
  - 适用于通过一个或多个参数初始化变量
- 拷贝初始化
  - 使用等号 `=` 初始化一个变量
  - 适用于通过一个参数初始化变量
  - 可以通过多个参数初始临时量，然后使用临时量拷贝初始化（有损效率，不建议）

TODO: 余与 C++98 基本一致，暂略

### 3.2.2 string对象上的操作

- 读写string对象
  - string 会自动忽略开头的空白字符
  - 遇到下一处空白字符停止读入
  - 示例：
    ```C++
    string s;
    cin >> s;
    cout << s << endl;
    ```
- 读取未知数量的string对象
  - 示例：
    ```C++
    string s;
    while (cin >> s)  // cin >> s 的返回值为输入流对象，放到条件表达式中可以用来判断流是否有效
    {
      cout << s << endl;
    }
    ```
- 使用 getline 读取一整行
  - 保留读入过程中遇到的空白字符
  - 直到遇到`换行符`停止读入（换行符也会被读入流，但不会被存入目标 string）
  - 示例：
    ```C++
    string s;
    while (getline(cin, s))  // getline(cin, s) 的返回值同样为输入流对象
    {
      cout << s << endl;
    }
    ```
- empty 操作
  - 返回 string 是否为空
  - 示例：
    ```C++
    string s;
    while (getline(cin, s))
    {
      if (!s.empty())
      {
        cout << s << endl;
      }
    }
    ```
- size 操作
  - 返回 string 对象的长度（字符个数）
  - 返回值类型为 `string::size_type`
    - 无符号类型
    - 足够存放下任何 string 对象的长度
  - ==注意：如果一条表达式中已经有 size() 函数，就不要再使用 int 了==
- 比较 string 对象
  - 大小写敏感
  - 对比字符串的长度和对应字符的字符序
  - 支持 `>`， `>=`， `<=`， `<`， `==`， `!=` 运算符
- 为 string 对象赋值
  - 示例：
    ```C++
    string s1(10, 'c'), s2;
    s1 = s2;
    ```
- 两个 string 对象相加
  - 操作结果为字符串的拼接
  - 示例：
    ```C++
    string s1 = "hello ", s2 = "world!\n";
    string s3 = s1 + s2;
    s1 += s2;
    ```
- 字面值和 string 对象相加
  - 标准库允许把==字符字面值==和==字符串字面值==转换为 string 对象
  - 当把 string 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保==每个==加法运算符两侧的运算对象==至少有一个==是 string
  - 注意：==字符串字面值和 string 是不同的类型==
  - 示例：
    ```C++
    string s2 = s1 + ", ";  // 正确
    string s3 = "hello" + ", "  // 错误
    string s4 = s5 + ", " + "world";  // 正确
    string s6 = "hello" + ", " + s7;  // 错误
    ```

### 3.2.3 处理string对象中的字符

- \<cctype> 头文件：提供函数，用来操作、判断字符的特性
  - isalnum(c)：当 c 是字母或数字时为真
  - isalpha(c)：当 c 是字母时为真
  - isdigit(c)：当 c 是数字时为真
  - isxdigit(c)：当 c 是十六进制数字时为真
  - isupper(c)：当 c 是大写字母时为真
  - islower(c)：当 c 是小写字母时为真
  - isgraph(c)：当 c 不是空格但可打印时为真
  - isprint(c)：当 c 是可打印字符时为真（c 是空格或 c 具有可视形式）
  - iscntrl(c)：当 c 是控制字符时为真
  - ispunct(c)：当 c 是标点符号时为真（c 不是控制字符、数字、字母、可打印空白字符中的一种）
  - isspace(c)：当 c 是空白字符时为真（c 是空格、制表符、回车符、换行符、进纸符中的一种）
  - tolower(c)：如果 c 是大写字母，则返回对应的小写字母；否则，原样返回
  - toupper(c)：如果 c 是小写字母，则返回对应的大写字母；否则，原样返回

- 使用范围 for 处理 string 中的每个字符（C++11 新标准）
  - 示例1：打印 string 对象中的每个字符到单独一行
    ```C++
    string s("hello world!");
    for (auto c : s)
    {
      cout << c << endl;
    }
    ```
  - 示例2：统计 string 对象中标点符号的个数
    ```C++
    string s("hello world!!!");
    decltype(s.size()) count = 0;
    for (auto c : s)
    {
      if (ispucnt(c))
      {
        ++count;
      }
    }
    cout << count << endl;
    ```
  - ==示例3==：将 string 对象中的小写字符改为大写
    ```C++
    string s("hello world!!!");
    for (auto &c : s)
    {
      c = toupper(c);
    }
    cout << s << endl; 
    ```

- 使用下标运算符处理 string 中的任意元素
  - 下标运算符的返回值是该位置上==字符的引用==
  - 索引的数据类型为 `string::size_type`（注意隐式转换规则）
  - 如果索引位置的字符不存在，则==结果是未定义==的
  - 示例：
    ```C++
    string s("hello world!!!");
    for (decltype(s.size()) index = 0;
         index != s.size() && !isspace(s[index]);
         ++index)
    {
      s[index] = toupper(s[index]);
    }
    cout << s << endl;
    ```

---
## 3.3_标准库类型vector

- vector：对象的集合
  - 所有对象的类型相同
  - 每个对象均有一个与之对应的索引
- 头文件：\<vector>
- 命名空间：std
- 注：
  - vector 是个类模板
  - 编译器根据模板创建类或函数的过程称为==实例化==

### 3.3.1 定义和初始化vector对象

- 初始化 vector 对象的方法
  - vector<T> v1; 
  - vector<T> v2(v1);
  - vector<T> v3 = v1;
  - vector<T> v4(n, val);
  - vector<T> v5(n);
  - vector<T> v6{a, b, c...};
    - C++11 新标准
  - vector<T> v7={a, b, c...};

### 3.3.2 向vector对象中添加元素

- push_back：把一个值当成 vector 对象的尾元素添加到 vector 对象的末尾
  - 示例：
    ```C++
    string word;
    vector<string> text;
    while (cin >> word)
    {
      text.push_back(word);
    }
    ```
- 注意：如果循环体内包含有向 vector 对象添加元素的语句，则不能使用范围 for 循环（范围 for 语句体内不应该改变其所遍历序列的大小）

### 3.3.3 其他vector操作

- vector 支持的操作
  - v.empty()
  - v.size()
  - v.push_back()
  - v[n]
  - v1 = v2
  - v1 = {a, b, c...}
  - v1 == v2
  - v1 != v2
  - <, <=, >=, >
- 注意：
  - 只有当元素的值可比较时，vector 对象才能被比较
  - vector 对象的下标从 0 开始
  - 不能通过下标形式向 vector 对象中添加元素
  - 不能通过下标形式访问不存在的元素
    - 确保下标合法的一种有效手段就是尽可能使用范围 for 语句

---
## 3.4_迭代器介绍

- 所有标准库容器都可以使用迭代器（只有少数几种同时支持下标运算符）
- 迭代器类似于指针类型
  - 间接访问对象
  - 可以从一个元素指向另一个元素
- 有效迭代器和无效迭代器
  - 有效：迭代器指向某个元素，或者指向容器==末尾的下一位置==
  - 无效：其他情况均属无效

### 3.4.1 使用迭代器

- 获得迭代器
  - 有迭代器的类型同时拥有返回迭代器的成员
  - begin()：返回指向第一个元素的迭代器
  - end()：返回指向末尾的下一位置的迭代器（尾后迭代器）
  - cbegin() 和 cend()：返回对应的 const_iterator（无论容器本身是否为 const，C++11 新标准）
    - 而 begin() 和 end() 是否返回 const_iterator 跟对应的对象有关

- 标准容器迭代器的运算符
  - `*iter`：返回迭代器 iter 所指元素的==引用==
    - 执行解引用的迭代器必须合法，并且确实指示着某个元素（尾后迭代器也不行）
  - `iter->mem`：解引用 iter 并获取该元素的名为 mem 的成员（等价于 `(*iter).mem`）
  - `++iter`：令 iter 指示容器中的下一个元素
  - `--iter`：令 iter 指示容器中的上一个元素
  - `iter1 == iter2`：判断两个迭代器是否相等（指向相同的元素，或者同时指向同一容器的尾后迭代器）
  - `iter1 != iter2`：判断两个迭代器是否不等
    - 所有标准库容器的迭代器都定义了 `==` 和 `!=` 运算符，但大多数没有定义 `<` 运算符

- 注意：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

### 3.4.2 迭代器运算

- vector 和 string 迭代器支持的运算（比标准容器多出来的部分）
  - `iter + n`：结果仍为迭代器，且结果迭代器与 iter 相比向前移动了 n 个位置
  - `iter - n`：结果仍为迭代器，且结果迭代器与 iter 相比向后移动了 n 个位置
  - `iter += n`：等价于 iter = iter + n
  - `iter -= n`：等价于 iter = iter - n
  - `iter1 - iter2`：结果为两个迭代器之间的距离
    - iter2 向左移动差值个位置将与 iter1 指向相同元素
    - 结果的数据类型为 `difference_type`，有正有负
  - `>`, `>=`, `<`, `<=`：指向的元素位置越靠后，则迭代器越大

- 示例：使用迭代器完成二分搜索
  ```C++
  //假设 text 为 string 类型的对象且有序
  auto beg = text.begin(), end = text.end();
  auto mid = beg + (end - beg) / 2;
  while (mid != end && *mid != sought)
  {
    if (sought < *mid)
    {
      end = mid;
    }
    else
    {
      beg = mid + 1;
    }
    mid = beg + (end - beg) / 2;
  }
  ```

---
## 3.5_数组

- 数组的大小确定不变
- 与 vector 相比，在某些特定场合下可以获得更好的性能（代价是损失一些灵活性）

### 3.5.1 定义和初始化内置数组

- 定义数组
  - 维度必须是一个常量表达式
  - 必须明确指定数组的类型（不能用 auto 关键字）
  - 数组元素必须为对象（不存在引用的数组）
  - 默认情况下，数组的元素被==默认初始化==

- ==字符数组==的特殊性
  - 可以使用==字符串字面值==初始化字符数组，但注意结尾会有一个空字符 `\0` 

- 复杂的数组声明
  - 示例：
    ```C++
    int *ptrs[10];  // ptrs 是一个数组，容量为10，数组元素的类型为 int *
    int &refs[10];  // 错误：不存在引用的数组
    int (*pArray)[10];  // pArray 是一个指针，指向的是一个数组，该数组的容量为10且数组元素类型为 int
    int (&rArray)[10];  // rArray 是一个引用，引用的是一个数组，该数组的容量为10且数组元素类型为 int 
    ```

- 注意：
  - 不能将数组的内容拷贝给其他数组作为其初始值
  - 不能用数组为其他数组赋值
  - 示例：
    ```C++
    int a1[] = {1, 2, 3};
    int a2 = a1;  // 错误：不能讲数组的内容拷贝给其他数组作为其初始值
    a2 = a1;  // 错误：不能用数组为其他数组赋值 
    ```

### 3.5.2 访问数组元素

- 可以使用==范围 for==语句或下标运算符访问数组元素
- 下标的类型为 `size_t`，定义在 `<cstddef>` 头文件（足够表示内存中任意对象的大小）

### 3.5.3 指针和数组

- 当使用数组作为一个 auto 变量的初始值时，推断得到的类型是==指针==（而非数组）
  - 示例：
    ```C++
    int a1[] = {1, 2, 3};
    auto a2(a1);  // a2 的类型为 int *，值为 a1 中首元素的地址
    ``` 
- 与之对比，`decltype(a1)` 返回的类型是 10 个整数构成的数组

- 尾后指针：可以设法获取数组元素之后的那个并不存在的元素的地址
  - 示例：
    ```C++
    int a1[] = {1, 2, 3};
    int *p = &a[3]; 
    ```
  - 注意：不能解引用或递增尾后指针

- C++11 新标准：标准库函数 begin() 和 end()
  - begin()：获取数组元素的首指针
  - end()：获取数组元素的尾后指针
  - 示例：
    ```C++
    int a1[] = {1, 2, 3};
    int *pBeg = begin(a1), *pEnd = end(a1);
    ```

- 指针运算（解引用、递增、比较、与整数相加、两个指针相减等）：与迭代器上的意义完全一致
  - 注意：
    - 如果计算所得的指针超出了数组范围将产生错误，而编译器一般发现不了这种错误
    - 指针相减的结果有正有负，为 `ptrdiff_t` 类型，定义在 `<cstddef>` 头文件（与 size_t 相同）

- 备注：对数组执行下标运算，起始是对指向数组元素的指针执行下标运算
  - 示例：
    ```C++
    int a1[] = {1, 2, 3};
    for (int *p = a1, i = 0; i < 3; ++i, ++p)
      *p; // 无需再次计算内存地址，效率高一些
    for (int i = 0; i < 3; ++i)
      a1[i];  // 等价于 *(a1 + i)，所以计算效率差一些
    ```

### 3.5.4 C风格字符串

- 对大多数应用来说，使用标准库 string 要比使用 C 风格字符串更安全、更高效

- TODO: 余与 C 基本一致，暂略

### 3.5.5 与旧代码的接口

- string 类型
  - 通过 c_str 函数返回字符数组
    - 注意：如果执行完 c_str() 函数后，程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份
- vector 类型
  - 使用数组初始化 vector 对象
    - 只需要指明待拷贝的第一个元素的地址，以及最后一个元素的下一位置的地址
    - 示例：
      ```C++
      int arr[] = {1, 2, 3, 4, 5, 6, 7};
      vector<int> iVec(begin(arr) + 1, end(arr) - 2);  // 拷贝的元素为 2, 3, 4, 5
      ```
---
## 3.6_多维数组

- 使用范围 for 语句处理多维数组（C++11 新标准）
  - 示例1：
    ```C++
    int ia[3][4];
    size_t cnt = 0;
    for (auto &row : ia)  // 这里是引用
    {
      for (auto &col : row)  // 这里也是引用
      {
        col = cnt;
        ++cnt;
      }
    }
    ```
  - 示例2：
    ```C++
    int ia[2][3] = {{1, 2, 3}, {4, 5, 6}};
    for (const auto &row : ia)  // 注意，这里使用引用是为了避免 row 被自动推断为指针类型
    {
      for (auto col : row)
      {
        cout << col <<endl;
      }
    }
    ```

- 指针和多维数组
  - 示例1：
    ```C++
    int ia[2][3] = {{1, 2, 3}, {4, 5, 6}};
    for (auto p = ia; p != ia + 2; ++p)
    {
        for (auto q = *p; q != (*p) + 3; ++q)
        {
          cout << *q << endl;
        }
    }
  - 示例2：
    ```C++
    int ia[2][3] = {{1, 2, 3}, {4, 5, 6}};
    for (auto p = begin(ia); p != end(ia); ++p)
    {
        for (auto q = begin(*p); q != end(*p); ++q)
        {
          cout << *q << endl;
        }
    }
    ```

TODO: 余与 C 基本一致，暂略