[TOC]

# 第6章_函数

---
## 6.1_函数基础

- 函数是一个==命名了的代码块==

TODO: 与 C 基本一致，暂略

### 6.1.1 局部对象

- 局部变量：形参和函数体内部定义的变量
- 局部变量的生命周期
  - 自动变量（形参）：只存在于块执行期间
  - 局部静态对象：
    - 执行路径第一次经过对象定义语句时初始化
    - 直至程序终止才被销毁
    - 如果没有显式的初始化，将执行值初始化（内置类型的局部静态变量初始化为 0）
- 注意：局部变量会隐藏在外层作用域中同名的其他所有声明

### 6.1.2 函数声明

- 函数声明也称函数原型
- 含有函数声明的头文件应该被包含到定义函数的源文件中（编译器负责验证函数的定义和声明是否匹配）

TODO: 余与 C++98 基本一致，暂略

### 6.1.3 分离式编译

TODO: 与 C++98 基本一致，暂略

---
## 6.2_参数传递

TODO: 与 C++98 基本一致，暂略

### 6.2.1 传值参数

- 实际上是把实参的拷贝传递给函数（如果拷贝大的类类型对象或容器对象，效率比较低）
- 需要该类型的形参支持拷贝操作按值传参
- 建议：在 C++ 语言中，建议使用引用类型的形参替代指针

TODO: 余与 C++98 基本一致，暂略

### 6.2.2 传引用参数

- 当某种类型不支持拷贝操作时，函数只能通过引用参数访问类型对象
- 建议：
  - 如果函数无需改变引用形参的值，最好将其声明为常量引用

TODO: 余与 C++98 基本一致，暂略

### 6.2.3 const形参和实参

- 当形参有顶层 const 时，传给它常量或非常量对象都是可以的（形参的顶层 const 被忽略掉了）
  - 注：所以无法通过形参是否具有顶层 const 对函数进行重载
- 指针或引用形参与 const（就是为了数据安全）
  - 可以使用非常量初始化一个底层 const 对象（但反过来不行）
  - 一个普通的引用必须用同类型的对象初始化
  - 示例：
    ```C++
    void reset(int &val) {...}
    void reset(int *val) {...}

    int i = 0;
    const int ci = i;
    string::size_type ctr = 0;

    reset(&i);  // 正确：调用 int * 版
    reset(&ci);  // 错误：不能用指向 const int 对象的指针初始化 int *
    reset(i);  // 正确：调用 int & 版
    reset(ci);  // 错误：不能把普通引用绑定到 const 对象上
    reset(42);  // 错误：不能把普通引用绑定到字面值上
    reset(ctr);  // 错误：类型不匹配
    ```

- 尽量使用常量引用
  - 因为不能把 const 对象、字面值、或者需要类型转换的对象传递给普通的引用形参
  - 如果一个函数定义了普通引用，那么它将无法用在一个使用同一参数，但参数类型为常量引用的函数中

### 6.2.4 数组形参

- 数组的两个特殊性质
  - 不允许拷贝数组：所以无法以传值的方式使用数组参数
  - 数组会被转换为指针：所以当为函数传递一个数组时，实际上传递的是指向数组首元素的指针

- 以数组作为形参的函数必须确保使用数组时不会越界
  - 使用标记指定数组长度
    ```C++
    void print(const char *cp)
    {
        if (cp)
        {
            while (*cp)
            {
                cout << *cp++;
            }
        }
    }
    ```
  - 使用标准库规范（传递首元素和尾后元素的指针）
    ```C++
    void print(const int *beg, const int *end)
    {
        while (beg != end)
        {
            cout << *beg++;
        }
    }
    ```
  - 显式传递一个表示数组大小的形参
    ```C++
    void print(const int c[], size_t size)
    {
        for (size_t i = 0; i != size; i++)
        {
            cout << c[i];
        }
    }
    ```

- 数组引用形参
  - 缺点：因为数组的大小是构成数组==类型的一部分==，所以会限制函数的可用性
    ```C++
    void print(int (&arr)[10])
    {
        for (auto elem : arr)
        {
            cout << elem;
        }
    }
    ```

- 传递多维数组
  ```C++
  void print(int (*mat)[10], int rowSize)
  {
      ...
  }
  ```

- 备注：当函数不需要对数组元素执行写操作的时候，数组形参应该指向 const 的指针

### 6.2.6 含有可变形参的函数

- C++11 新标准提供了两种主要方法，用来编写能处理不同数量实参的函数
  - 如果所有的实参类型相同，可以传递一个名为 initializer_list 的标准库类型
  - 如果实参的类型不同，可以编写一种叫做==可变参数模板==的特殊函数（见 16.4 节）

- 备注：C++ 还支持**省略符**形参，但该功能一般只用于与 C 函数交互的接口程序

- initializer_list 形参
  - 头文件：<initializer_list>
  - 适用条件：
    - 实参数量未知
    - 全部实参的类型相同
  - 提供的操作
    - `initializer_list<T> lst`: 默认初始化，T类型元素的空列表    
    - `initializer_list<T> lst{a, b, c...}`: lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const
    - `lst2(lst)`: 拷贝或赋值一个 initializer_list 对象，不会拷贝列表中的元素；拷贝后原始列表和副本共享元素
    - `lst2 = lst`: 同上
    - `lst.size()`: 列表中的元素数量
    - `lst.begin()`: 返回指向 lst 中首元素的指针
    - `lst.end()`: 返回指向 lst 中==尾后元素==的指针
  - 注意：initializer_list 对象中的元素永远是==常量值==
  - 示例1：
    ```C++
    void error_msg(initializer_list<string> il)
    {
        for (auto beg = il.begin(); beg != il.end(); ++beg)
        {
            cout << *beg << " ";
        }
        cout << endl;
    }

    // expected 和 actual 是 string 对象
    if (expected != actual)
    {
        error_msg({"functionX", expected, actual});
    }
    else
    {
        error_msg({"functionX", "okay"});
    }
    ```
  - 示例2：因为 initializer_list 包含 begin 和 end 成员，所以可以使用范围 for
    ```C++
    void error_msg(ErrCode e, initializer_list<string> il)
    {
        cout << e.msg() << ": ";
        for (const auto &elem : il)
        {
            cout << elem << " "
        }
        cout << endl;
    }
    ```

- 省略符形参
  - 是为了便于 C++ 程序访问某些特殊的 C 代码而设置的
  - 不应用于其他目的


---
## 6.3_返回类型和return语句

### 6.3.1 无返回值函数

TODO: 与 C++98 基本一致，暂略

### 6.3.2 有返回值函数

- 值是如何被返回的
  - 按值方式：返回的值用于初始化==调用点的一个临时量==，该临时量就是函数调用的结果
  - 按引用方式：如果函数返回引用，则该引用仅是它所引用对象的一个别名
  - 注意：==不要返回局部对象的引用或指针==

- 函数的返回类型决定函数调用的返回值是否是左值
  - 调用一个返回引用的函数得到左值
    - 可以对函数返回的非常量引用进行赋值
  - 其他返回类型得到右值

- 列表初始化返回值（C++11 新标准）
  - 函数可以返回花括号包围的值的列表
  - 该列表可以用来对表示函数返回值的==临时量进行初始化==
    - 如果函数返回的是内置类型，则花括号包围的列表最多包含一个值（该值所占空间不应大于目标类型的空间）
    - 如果函数返回的是类类型，由类本身定义初始值如何被使用

- 主函数 main 的返回值
  - cstdlib 头文件定义了两个预处理变量（使返回值与机器无关）
    - `EXIT_FAILURE`
    - `EXIT_SUCCESS`

TODO: 余与 C++98 基本一致，暂略

### 6.3.3 返回数组指针

- 因为数组不能被拷贝
  - 所以，函数不能直接返回数组
  - 但是，函数可以返回==数组的指针或引用==

- 声明一个返回数组指针的函数
  - 使用类型别名
    ```C++
    typedef int arrT[10];
    using arrT = int[10];

    arrT *func(int i);
    ```
  - 不使用类型别名：数组的维度必须跟在函数名字之后
    ```C++
    int (*func(int i))[10];
    ```

- 使用尾置返回类型（C++11 新标准）
  - 适用范围
    - 任何函数的定义都能使用尾置返回
    - 这种形式对于返回类型比较复杂的函数最有效
  - 使用方法
    - 在形参列表后以一个 `->` 引出函数的返回类型
    - 在本该出现返回类型的地方放置一个 `auto`
  - 示例
    ```C++
    auto func(int i) -> int(*)[10];
    ```

- 使用 decltype
  - 适用情况：已知函数返回的指针将指向哪个数组
  - 注意：decltype 并不负责把数组类型转换成对应的指针，所以 decltype 的结果是个数组，需要在声明时添加一个 `*` 表示数组指针
  - 示例：
    ```C++
    int odd[] = {1, 3, 5, 7, 9};
    int even[] = {0, 2, 4, 6, 8};
    
    decltype(odd) * arrPtr(int i)
    {
        return (i % 2) ? &odd : &even;
    }
    ```

---
## 6.4_函数重载

- 重载函数：同一作用域内，几个函数名字相同，但形参列表不同
  - main 函数不能重载
  - 重载函数间需要在形参数量或形参类型上有所不同
  - 不允许两个函数除了返回类型外其他所有的要素都相同（返回类型不是函数签名的一部分）

- 重载和 const 形参
  - 顶层 const 无法用来区分形参（一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来）
  - 底层 const 可以用来区分形参（如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载）
  - 注意：当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数（最佳匹配）

- const_cast 和重载
  - 示例：
    ```C++
    const string &shorterString(const string &s1, const string &s2)
    {
        return s1.size() <= s2.size() ? s1 : s2;
    }

    string &shorterString(string &s1, string &s2)
    {
        // 这样操作是安全的
        // 因为明确知道 s1 和 s2 不是常量，而要调用的 shorterString 接受的是常量引用
        auto &r = shorterString(const_cast<const string &>(s1), const_cast<const string &>(s2));
        return const_cast<string &>(r);
    }
    ```

- 调用重载的函数
  - 通过==函数匹配==（又称重载确定）把函数调用与一组重载中的某一个函数关联起来
  - 三种可能的结果
    - ==编译器==找到一个与实参**最佳匹配**的函数（所以是静态绑定），并生成调用该函数的代码
    - 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配**的错误
    - 有==多于一个==函数可以匹配，但是每一个都不是明显的最佳选择，此时也将发生错误，即==二义性调用==

- 建议：
  - 最好只重载那些确实非常相似的操作
  - 一般来说，是否重载函数要看哪种（重载或者不重载）更容易理解

### 6.4.1 重载与作用域

- 注意：在 C++ 语言中，==名字查找发生在类型检查之前==
  - 一旦在当前作用域中找到了所需的名字（只是名字，不关心任何类型信息），编译器就会忽略掉外层作用域中的同名实体

---
## 6.5_特殊用途语言特性

### 6.5.1 默认实参

- 调用含有默认实参的函数时，可以包含该实参，也可以省略该实参
- 为形参定义默认值时，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值

- 默认实参声明
  - 在给定的作用域中一个形参只能被赋予一次默认实参（不能重复指定默认实参）
  - 函数的后续声明可以为之前那些没有默认值的形参添加默认参数
  - 示例：
    ```C++
    // 注意，以下都是函数的声明
    string screen(sz, sz, char = ' ');
    string screen(sz, sz, char = '*');  // 错误：不能修改一个已经存在的默认值
    string screen(sz = 24, sz = 80, char);  // 正确：添加默认实参
    ```

- 默认实参初始值
  - 局部变量==不能==作为默认实参
  - 除此之外，只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认实参
  - 用作默认实参的==名字==在**函数声明**所在的作用域内==解析==，而这些名字的==求值过程==发生在**函数调用**时
  - 示例：
    ```C++
    // wd, def 和 ht 为全局变量
    sz wd = 80;
    char def = ' ';
    sz ht();
    
    string screen(sz = ht(), sz = wd, char = def);  // 正确：函数声明，并指定了默认实参
    
    string window = screen();  // 正确：使用默认实参调用函数

    void f2()
    {
        def = '*';  // 改变默认实参的值
        sz wd = 100;  // 定义新的局部变量，会隐藏外层定义的 wd，但没有改变默认值
        window = screen();  // 调用 screen(ht(), 80, '*')
    }  
    ```

- 备注：
  - 当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序
    - 尽量让不怎么使用默认值的形参出现在前面
    - 而让那些经常使用默认值的形参出现在后面

### 6.5.2 内联函数和constexpr函数

- 内联函数
  - 使用方法：在函数的==返回类型前==加上关键字`inline`即可
  - 适用场景：用于规模较小、流程直接、调用频繁的函数
  - 注意：
    - 内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求
    - 很多编译器都不支持内联==递归函数==

- constexpr 函数
  - 定义方法:
    - 函数的==返回值==及==所有形参==的类型都是==字面值==类型
    - 函数体中必须==有且仅有==一个 return 语句
    - 函数体中可以包含其他语句，只要这些语句在运行时不执行任何操作就行（例如空语句、类型别名、using 声明）
  - 用途：
    - 执行初始化任务：编译器把对 constexpr 函数的调用替换成其结果值（为了能在编译过程中随时展开，constexpr 函数被隐式地指定为**内联函数**）
  - 注意：允许 constexpr 函数的返回值==并非一个常量==
    - 当调用 constexpr 函数时，由编译器检查函数的返回值是否为常量
      - 如果是常量，编译时直接使用常量结果
      - 否则，使用对应的函数调用过程
  - 示例：
    ```C++
    constexpr int new_sz() { return 42; }
    constexpr int foo = new_sz();  // 正确：foo 是一个常量表达式

    // 如果 scale 的实参是常量表达式，则其返回结果也是常量表达式；否则，不是
    constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

    int arr[scale(2)];  // 正确
    int i = 2;
    int a2[scale(i)];  // 错误：scale(i) 不是常量表达式
    ```

- 注意：内联函数和 constexpr 函数应该定义在头文件中
  - 因为编译器想要展开函数仅有函数声明是不够的，还需要函数的定义

### 6.5.3 调试帮助

> 程序可以包含一些用于调试的代码，但是这些代码==只在开发程序==时使用

- assert ==预处理==宏
  - 一般形式：`assert(expr);`
  - 执行过程
    - 对 expr 求值
    - 如果求值结果为假（即0），则 assert 输出信息并终止程序的执行
    - 如果求值结果为真（即1），则 assert 什么都不错
  - 头文件：\<cassert>
  - 用途：检查==不能发生==的条件
  - 注意：
    - 不能替代真正的运行时逻辑检查
    - 也不能替代程序本身应该包含的错误检查
  - 备注：
    - assert 是预处理名字
      - 预处理名字由预处理器（而非编译器）管理，所以可以直接使用预处理名字而无需提供 using 声明，也不用指定名字空间
    - 宏也由预处理器使用，所以宏名字在==程序内==必须唯一
    - assert 宏依赖于 NDEBUG 变量
      - 如果定义了 NDEBUG 变量，则 assert 什么也不错
      - 否则，assert 执行运行时检查
      - 默认状态下没有定义 NDEBUG 变量

- NDEBUG 预处理变量
  - 定义 NDEBUG 变量
    - 使用 `#define` 语句定义 NDEBUG
    - 使用编译器的命令行选项：
      ```shell
      # 等价于在 main.c 文件的一开始写 #define NDEBUG
      CC -D NDEBUG main.c  # Microsoft compiler
      ```
  - 使用 NDEBUG 编写自定义的==条件调试==代码
    - 示例：
      ```C++
      void print(string word, size_t threshold)
      {
      #ifndef NDEBUG
        if (word.size() < threshold)
        {
            cerr << "Error: " << __FILE__
                 << " : in function " << __func__
                 << " at line " << __LINE__ << endl
                 << "      Compiled on " << __DATE__
                 << " at " << __TIME << endl
                 << "      Word read was \"" << word 
                 << "\": Length too short" << endl;
        }      
      #endif // NDEBUG
      }
      ```

- 备注：
  - `__func__`: 当前调试的函数的名字（由编译器定义）
  - `__FILE__`: 文件名的字符串字面值（预处理器定义）
  - `__LINE__`: 当前行号的整型字面值（预处理器定义）
  - `__TIME__`: 文件编译时间的字符串字面值（预处理器定义）
  - `__DATE__`: 文件编译日期的字符串字面值（预处理器定义）

---
## 6.6_函数匹配

> 当几个重载函数的形参数量相等，以及某些形参的类型可由其他类型转换得来时，需要按照一定的步骤进行函数匹配

1. 确定候选函数
    - 候选函数须具备两个特征
      - 与被调用函数同名（仅仅是名字）
      - 其声明在调用点可见
1. 确定可行函数
    - 可行函数须具备两个特征
      - 其形参数量与本次调用提供的实参数量相等（考虑默认参数）
      - 每个实参的类型与对应的形参类型==相同==，或者能==转换==成形参的类型
1. 寻找最佳匹配（如果有的话）
    - 基本思想：实参类型与形参类型越接近，则它们匹配的越好
    - 具体操作：编译器依次检查每个实参以确定哪个函数是最佳匹配
    - 匹配成功所需的两个标志：
      - 该函数每个实参的匹配都==不劣于==其他可行函数需要的匹配
      - 该函数至少一个实参的匹配==优于==其他可行函数提供的匹配
    - 二义性调用的标志：
      - 只满足了匹配成功的第一个标志
      - 没有满足第二个标志

### 6.6.1 实参类型转换

> 本节讨论如何寻找并最佳匹配

- 编译器将形参类型划分为几个等级，按从高到低排列如下
  1. 精确匹配
      - 实参类型和形参类型相同
      - 实参从数组类型或函数类型转换成对应的指针类型（参见 6.7 节）
      - 向实参添加顶层 const，或者从实参中删除顶层 const
  1. 通过 const 转换实现的匹配（参见 4.11.2 节）
  1. 通过类型提升实现的匹配（参见 4.11.1 节）
  1. 通过算数类型转换（参见 4.11.1 节），或指针转换（参见 4.11.2 节）实现的匹配
  1. 通过类类型转换实现的匹配（参见 14.9 节）

- 注意：
  - 只有精确匹配，才能阻止类型提升
    ```C++
    void ff(int);
    void ff(short);
    ff('a');  // char 被提升为 int，所以最终调用 ff(int)
    ```
  - 所有算数类型转换的==级别都一样==
    ```C++
    void manip(long);
    void manip(float);
    manip(3.14)  // 错误：二义性调用
    ```
  - 如果重载函数的区别在于他们的==引用类型==的形参是否引用了 const，或者==指针类型==的形参是否指向 const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数
    ```C++
    Record lookup(Account &);
    Record lookup(const Account &);
    const Account a;
    Account b;

    lookup(a);  // 调用 lookup(const Account &)
    lookup(b);  // 调用 lookup(Account &)
    ```

---
## 6.7_函数指针

- 函数指针
  - 指向的是==特定类型==的函数而非对象
  - 函数的类型由它的==返回类型==和==形参类型==共同决定（与函数名无关）

- 声明方法：声明一个指向某函数的指针，只需要把该函数的声明中的函数名替换成指针即可
  - 示例1：传统方法
    ```C++
    bool lengthCompare(const string &, const string &);
    // 对应的函数指针
    bool (*pf)(const string &, const string &);
    ```
  - 示例2：使用 typedef 或 decltype
    ```C++
    // 声明两个等价的函数类型
    typedef bool Func(const string &, const string &);
    typedef decltype(lengthCompare) Func;

    // 声明两个等价的函数指针
    typedef bool (*pFunc)(const string &, const string &);
    typedef decltype(lengthCompare) *pFunc;
    ```
  - 注意：
    - decltype 返回类型时，不会自动转换成指针类型
    - 使用 decltype 定义返回类型时，需要明确知道函数的返回类型是什么（与哪种类型对应）

- 使用方法
  - 把函数名作为一个值使用时，该函数自动地转换成指针
  - 可以直接使用指向函数的指针来调用函数（无需提前解引用）
  - 示例：
    ```C++
    // 以下两个表达式等价
    pf = lengthCompare;
    pf = &lengthCompare;

    // 以下三个表达式等价
    bool b1 = lengthCompare("hello", "world");
    bool b2 = pf("hello", "world");
    bool b3 = (*pf)("hello", "world");
    ```

- 重载函数的指针：指针类型必须与重载函数中的某一个精确匹配
  ```C++
  void ff(int *);
  void ff(unsigned int);

  void (*pf1)(unsigned int) = ff;  // pf1 指向 ff(unsigned int)
  void (*pf2)(int) == ff;  // 错误：无法找到类型匹配的函数
  double (*pf3)(int *) == ff;  // 错误：无法找到类型匹配的函数
  ```

- 函数指针作为形参：形参看起来是函数类型，实际上却是当成指针使用（与数组类似）
  - 此时，可以直接把函数名作为实参使用（会自动转换成指针）
  ```C++
  // 以下两个声明等价
  void useBigger(const string &s1, const string &s2, bool pf(const string &1, const string &2));
  void useBigger(const string &s1, const string &s2, bool (*pf)(const string &1, const string &2));

  // 把函数作为实参使用
  useBigger(s1, s2, lengthCompare);
  ```

- 函数指针作为函数的返回值：必须把返回的函数写成指针类型（编译器不会自动地将函数返回类型当成对应的指针类型，与数组类似）
  - 示例1：使用类型别名
    ```C++
    using F = int(int *, int);  // F 是函数类型，不是指针
    using pF = int (*)(int *, int);  // pF 是函数指针类型

    pF f1(int);  // 正确
    F f2(int);  // 错误：函数类型不能作为函数的返回值
    F * f3(int);  // 正确：显式指定返回类型为 F 的指针类型
    ```
  - 示例2：使用尾置返回类型
    ```C++
    auto f1(int) -> int (*)(int *, int)
    ```

- 注意：
  - 指向不同函数类型的指针间==不能存在转换规则==