[TOC]

# 第13章_拷贝控制

- 类通过构造函数控制在创建此类型的对象时做什么
- 类通过一些特殊的成员函数控制类型的对象在拷贝、赋值、移动或销毁时做什么
  - 拷贝构造函数
  - 拷贝赋值运算符
  - 移动构造函数
  - 移动赋值运算符
  - 析构函数
- 备注
  - 拷贝构造函数和移动构造函数定义了当用同类型的另一个对象==初始化==本对象时做什么
  - 拷贝赋值运算符和移动赋值运算符定义了将一个对象==赋予==同类型的另一个对象时做什么
- 注意：如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它们生成默认的操作

---
## 13.1_拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

- 一般形式：构造函数的==第一个==参数是==自身类类型的引用==，且任何额外的参数都有默认值
  - 注意：
    - 拷贝构造函数通常不应该是 explicit 的（在几种情况下都会被隐式地使用）
    - 拷贝构造函数的第一个参数通常是自身类类型的 ==const 引用==
  - 备注：拷贝构造函数会被用来==初始化非引用类类型==参数
      - 这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型
        - 为了调用拷贝构造函数，必须拷贝它的实参
        - 为了拷贝实参，又需要调用拷贝构造函数，如此会陷入无限循环

- 合成拷贝构造函数：
  - 触发条件：没有为一个类定义拷贝构造函数
  - 默认行为：逐成员拷贝，即将参数（自身类类型的引用）的（非 static）成员逐个==拷贝==到正在创建的对象中
    - 每个成员的类型决定了它如何拷贝
      - 内置类型的成员：直接拷贝
      - 类类型的成员：使用其拷贝构造函数来拷贝
      - 数组：逐元素拷贝，拷贝方式依赖于元素的类型（同前所述，内置类型和类类型）
  - 注意：
    - 即使为类定义了其他==构造函数==，编译器也会合成一个拷贝构造函数
    - 对于某些类来说，合成拷贝构造函数用来阻止拷贝该类类型的对象（参见 13.1.6 节）
  - 示例：合成的拷贝构造的等价示例
    ```C++
    class SalesData
    {
    public:
        SalesData(const SalesData &);
    private:
        std::string bookNo;
        int units_sold = 0;
        double revenue = 0.0;
    };

    // 逐成员拷贝的等价过程
    SalesData::SalesData(const SalesData & orig):
        bookNo(orig.bookNo),
        units_sold(orig.units_sold),
        revenue(orig.revenue) { }
    ```

- 直接初始化与拷贝初始化
  - 直接初始化：编译器使用==普通的函数匹配==来选择与所提供的参数==最匹配的构造函数==
  - 拷贝初始化：将右侧运算对象==拷贝到==正在创建的对象中
    - 拷贝操作通过拷贝构造函数或移动构造函数（参见 13.6.2 节）完成
    - 如果需要的话，还要进行类型转换
  - 示例：
    ```C++
    string dots(10, '.');  // 直接初始化
    string s(dots);  // 直接初始化（这个主意下，可以暂时理解为没有符合拷贝初始化的发生情况）
    string s2 = dots;  // 拷贝初始化
    string null_book = "9-999-99999-9";  // 拷贝初始化。注意，在拷贝之前，需要先使用字符串隐式构造一个临时的 string 对象。可见，拷贝初始化时，一般情况下要有一个同类型的对象以供拷贝
    string nines = string(10, '9');  // 拷贝初始化
    ```
  - 注意：编译器可以（但不必须）绕过拷贝构造函数，选择直接创建对象，来进行代码优化
    - 示例：编译器绕过拷贝构造函数的等价示例
      ```C++
      // 对于原始的需要执行拷贝构造的代码
      string null_book = "9-999-99999-9";
      // 可以被编译器改写为
      string null_book("9-999-99999-9");
      ```

- 拷贝初始化在下列情况下发生
  - 使用 `=` 运算符==定义变量==
  - 将一个对象作为实参传递给一个==非引用类型==的形参
  - 从一个返回类型为==非引用类型==的函数返回一个对象
  - 用==花括号==列表初始化一个==数组==中的元素或一个==聚合类==中的成员
  - 备注：某些类类型还会对它们所分配的对象使用拷贝初始化
    - 例如，标准库容器调用其 insert 和 push 成员时，会拷贝初始化其元素
    - 与之对比，标准库容器调用其 emplace 成员时，会直接初始化其元素

- 拷贝初始化的限制
  - 如果使用的初始值要求通过一个 explicit 的==构造函数==来进行==类型转换==，那么使用拷贝初始化还是直接初始化就==不是无关紧要==的了
  - 示例：
    ```C++
    vector<int> v1(10);  // 正确：直接初始化
    vector<int> v2 = 10;  // 错误：接受大小参数的构造函数是 explicit 的。也就是说，无法根据给定的数值 10，隐式构造一个临时的 vector<int>
    void f(vector<int>);  // f 的参数进行拷贝初始化
    f(10);  // 错误：原因同上
    f(vector<int>(10));  // 正确：显式调用接受大小的构造函数构造一个临时量
    ```

### 13.1.2 拷贝赋值运算符

- 拷贝赋值运算符
  - 一般形式：重载赋值运算符，并且其==唯一一个==参数是==自身类类型的引用==
  - 备注：标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用

- 合成拷贝赋值运算符：
  - 触发条件：未显式定义一个类的拷贝赋值运算符
  - 默认行为：将右侧运算对象（位于参数列表，类型为自身类类型的引用）的每个非 static 成员赋予左侧运算对象的对应成员
    - 每个成员的类型决定了它如何被赋值
      - 内置类型的成员：直接使用 `=` 运算符
      - 类类型的成员：使用其拷贝赋值运算符
      - 数组：逐元素拷贝赋值，拷贝赋值的方式依赖于元素的类型（同前所述，内置类型和类类型）
    - 返回值：指向其左侧运算对象的引用
  - 示例：合成的拷贝赋值运算符的等价示例
    ```C++
    SalesData & SalesData::operator=(const SalesData & rhs)
    {
        bookNo = rhs.bookNo;
        units_sold = rhs.units_sold;
        revenue = rhs.revenue;
        return *this;
    }
    ```
  - 注意：对于某些类来说，合成拷贝赋值运算符用来禁止该类类型对象的赋值（参见 13.1.6 节）

- 重载运算符：
  - 本质：仍然是函数
  - 一般形式：函数名由 `operator` 关键字后接要定义的运算符的符号组成，其余部分同一般的成员函数
  - 注意：对于某些运算符，必须定义为成员函数（例如赋值运算符）
    - 如果一个运算符是一个成员函数
      - 左侧运算对象：绑定到隐式的 this 参数
      - 如果是二元运算符，则其右侧运算对象作为显式参数传递

- 备注：对构造函数和赋值运算符的一点总结
  - 构造函数
    - 用途：在初始化对象时，从无到有的==构建对象==
      - 注意：成员的初始化是在函数体执行之前完成的
    - 分类：
      - 默认构造函数：参数列表为空
      - 拷贝构造函数：参数列表中的第一个参数为自身类类型的引用
      - 移动构造函数：将资源的所有权从参数列表给定的参数转移给当前对象
      - 转换构造函数：参数列表中的参数不是自身类类型
  - 赋值运算符
    - 用途：对已有的对象，通过赋值的方式==修改其值==
    - 分类：
      - 拷贝赋值运算符：（就是同类型之间的赋值运算符）参数列表中的参数为自身类类型的引用
      - 移动赋值运算符：将资源的所有权从右侧参数转移给左侧参数
      - 转换赋值运算符：右侧参数和左侧参数的类型不同，但仍然可以赋值
  - 注意：一定要区分开对象的初始化、拷贝、以及赋值使用的分别是哪些函数

### 13.1.3 析构函数

- 析构函数：
  - 一般形式：名字由波浪号接类名构成，没有返回值，不接受参数
  - 作用：
    - 先执行析构函数体（即类设计者定义的用来收尾的任意动作）
    - 再按照成员的==初始化顺序的逆序==销毁对象的非 static 成员
      - 析构部分是隐式的，销毁时发生什么完全依赖于被销毁的成员的类型
        - 类类型成员：执行其析构函数
          - 智能指针属于类类型
        - 内置类型：没有析构函数
          - 内置指针类型属于内置类型
    - 注意：
      - 隐式销毁一个==内置指针类型==的成员，==不会== delete 它所指向的对象
      - 隐式销毁一个==智能指针类型==的成员，==会==自动销毁它所指向的对象
  - 注意：
    - 析构函数是类的成员函数
    - 析构函数不能被重载（因为不接受参数）
      - 因此，对一个给定类，析构函数是唯一的
    - 析构函数自身并不直接销毁成员
      - 成员是在析构函数体之后隐含的析构阶段中被销毁的

- 合成析构函数
  - 触发条件：未显式定义一个类的析构函数
  - 默认行为：析构函数的函数体为空
    - 这意味着合成的析构函数只按照对象成员的初始化顺序的逆序来销毁其非 static 成员
  - 注意：对于某些类来说，合成析构函数被用来阻止该类型的对象被销毁（参见 13.1.6 节）

- 析构函数在下列情况下被调用（无论何时一个对象被==销毁==，就会自动调用其析构函数）
  - 变量离开其作用域
  - 当一个对象被销毁时，其成员被销毁
  - 当一个容器被销毁时，其元素被销毁
  - 对于动态分配的对象，当指向它的指针引用 delete 运算符时被销毁
  - 对于临时对象，当创建它的完整表达式结束时被销毁
  - 示例：
    ```C++
    {  // 一个新的作用域
        SalesData *p = new SalesData;
        auto p2 = make_shared<SalesData>();
        SalesData item(*p);  // 拷贝构造
        vector<SalesData> vec;
        vec.push_back(*p2);  // 拷贝构造
        delete p;
    }
    ```

### 13.1.4 三/五法则

- 需要析构函数的类也需要拷贝构造函数和（拷贝）赋值运算符
  - 例如：类中使用了内置指针类型的成员来管理堆内存
- 需要拷贝构造函数的类也需要（拷贝）赋值运算符，反之亦然（但不一定需要析构函数）
  - 例如：需要为类的每个对象分配一个独一无二的编号时
- 注意：==这里描述的三/五法则有局限性，建议遵循更新的三/五法则==

### 13.1.5 使用=default

- `=default`：用来显式地要求编译器生成合成的版本
  - 注意：
    - 在==类内==使用 `=default` 修饰成员的声明时，合成的函数将是隐式地声明为内联的
    - 如果不希望合成的成员函数是内联函数，应该只对成员的==类外定义==使用 `=default`
    - 只能对==具有合成版本==的成员函数使用 `=default`，包括
      - 默认构造函数
      - 拷贝构造函数
      - 拷贝赋值运算符
      - 移动构造函数
      - 移动赋值运算符
      - 析构函数
  - 示例：
    ```C++
    class SalesData
    {
    public:
        SalesData() = default;  // 内联的默认构造函数
        SalesData(const SalesData &) = default;  // 内联的拷贝构造函数
        SalesData & operator=(const SalesData &);  // 拷贝赋值运算符的声明
        ~SalesData() = default;  // 内联的析构函数
    };

    SalesData & SalesData::operator=(const SalesData &) = default;  // 类外定义的默认的拷贝赋值运算符
    ```

### 13.1.6 阻止拷贝

- 定义删除的函数（C++11 新标准）
  - 作用：虽然对函数进行了声明，但不能以任何方式使用它们
  - 一般形式：在函数声明的参数列表后面加上 `=delete`
  - 适用场景：例如 iostream 类需要阻止拷贝，以避免多个对象读取或写入相同的 IO 缓冲
  - 注意1：与 `=default` 不同的是，`=delete`
    - 必须出现在函数==第一次声明==的时候
    - 可以对任何函数（包括拷贝控制成员）指定 `=delete`（例如：希望引导函数匹配过程时）
  - 注意2：对于析构函数已删除的类型，是无法销毁此类型的对象的
    - 编译器将不允许定义该类型的变量或创建该类型的临时对象，也不允许释放指向该类型动态分配对象的指针
    - 如果一个类有==某个成员==的类型删除了析构函数，则不能定义该类的变量或临时对象
    - 但是，可以==动态分配==上述类型的对象（一旦分配就无法销毁）

- 合成的拷贝控制成员可能是删除的
  - 如果类的==某个成员==的==析构函数==是删除的或不可访问的，则该类的以下合成成员被定义为删除的
    - 默认构造函数
    - 合成拷贝构造函数
    - 合成析构函数
  - 如果类的==某个成员==的==拷贝构造函数==是删除的或不可访问的，则该类的以下合成成员被定义为删除的
    - 合成拷贝构造函数
  - 如果类的==某个成员==的==拷贝赋值运算符==是删除的或不可访问的，则该类的以下合成成员被定义为删除的
    - 合成拷贝赋值运算符
  - 如果类==有一个 const 成员或引用成员==，则类的以下合成成员被定义为删除的
    - 合成拷贝赋值运算符
  - 如果类满足以下任一条件，则该类的==默认构造函数==被定义为删除的
    - 有一个==引用成员==，该成员没有类内初始化器
    - 有一个 ==const 成员==，该成员没有类内初始化器且该成员未显式定义默认构造函数
  - 备注：以上规则从本质上来说就是，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的

- private 拷贝控制（旧标准，不建议使用）
  - 建议：希望阻止拷贝的类应该使用 `=delete` 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不是将它们声明为 private 的
  - 备注：
    - 声明但不定义一个成员函数是合法的（对此只有一个例外，参见 15.2.1 节）
    - 将类的成员函数声明为 private 的，并且不对其进行定义，无法阻止友元对其私有成员函数的访问。一旦出现这种情况，虽然编译可以通过，但是会出现链接错误，反而更不好排查。

- 建议：
  - 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符（无论是显式地还是隐式的）

---
## 13.2_拷贝控制和资源管理

- 管理类外资源的类必须定义拷贝控制成员，使类的行为看起来像一个值或者像一个指针
  - 像一个值：对应深拷贝
  - 像一个指针：对应浅拷贝
- 备注：
  - 标准库容器和 string 类为深拷贝
  - 默认情况下 shared_ptr 类提供浅拷贝
  - IO 和 unique_ptr 既不提供深拷贝，也不提供浅拷贝（因为不支持拷贝和赋值）

### 13.2.1 定义行为像值的类

- 为了使类的行为像值（深拷贝），需要
  - 定义拷贝构造函数
  - 定义析构函数
  - 定义拷贝赋值运算符
  - 示例：
    ```C++
    class HasPtr
    {
    public:
        HasPtr(const std::string &s = std::string()) : ps(new std::string(s)), i(0) { }
        HasPtr(const HasPtr &p) : ps(new std::string(*p.ps)), i(p.i) { }
        HasPtr & operator=(const HasPtr &);
        ~HasPtr() { delete ps; }
    private:
        std::string *ps;
        int i;
    };

    HasPtr & HasPtr::operator=(const HasPtr &rhs)
    { 
        if (this == &rhs)
            return *this;

        auto newp = new string(*rhs.ps);
        delete this.ps;
        this.ps = newp;
        this.i = rhs.i;
        return *this;
    }
    ```
- 注意：
  - 对于拷贝构造函数和析构函数，因为涉及到的只有当前对象，所以逻辑十分清晰
  - 对于拷贝赋值运算符，同时涉及到了对左侧对象的析构，以及对右侧对象的拷贝。因此，在编写时需要注意以下问题
    - 如果将一个对象赋予它自身，赋值运算符必须正常工作
    - 如果赋值运算符工作期间出现了异常，左侧运算对象的状态仍然有意义
      - 为了做到这点，通常先拷贝右侧对象的资源，再销毁左侧对象的资源

### 13.2.2 定义行为像指针的类

- 为了使类的行为像指针（浅拷贝），两种实现方法
  - 使用 `shared_ptr` 间接管理资源（建议采用这种方法）
  - 使用`引用计数` -- 类直接管理资源

- 使用 `shared_ptr`：（暂略）

- 使用引用计数
  - 工作方式
    - 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数
    - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，同时递增引用计数
    - 析构函数递减引用计数。如果计数器变为 0，则释放资源
    - 拷贝赋值运算符递增右侧运算对象的引用计数，递减左侧对象的引用计数。如果左侧对象的计数器变为 0，则释放对应的资源
  - 计数器的存放位置：
    - 可以保存在动态内存中
    - 注：不能使用静态成员变量，因为静态成员变量归该类的所有对象共享使用；而引用计数是在存在拷贝关系的类之间共享使用
  - 示例：
    ```C++
    class HasPtr
    {
    public:
        HasPtr(const std::string &s = std::string()):
            ps(new std::string(s)), i(0), use(new std::size_t(1)) { }
        HasPtr(const HasPtr &p):
            ps(p.ps), i(p.i), use(p.use) { ++*use; }
        HasPtr & operator=(const HasPtr &);
        ~HasPtr();
    private:
        std::string *ps;
        int i;
        std::size_t *use;
    };
    
    HasPtr & HasPtr::operator=(const HasPtr &rhs)
    {
        if (this == &rhs)
            return *this;

        ++*rhs.use;

        if (--*use == 0)
        {
            delete ps;
            delete use;
        }
        
        ps = rhs.ps;
        i = rhs.i;
        use = rhs.use;

        return *this;
    }

    ~HasPtr::HasPtr()
    {
        if (--*use == 0)
        {
            delete ps;
            delete use;
        }
    }
    ```

---
## 13.3_交换操作

- 管理资源的类通常还定义一个名为 `swap` 的函数
  - 对于那些与重排元素顺序的算法一起使用的类，定义 swap 是非常重要的（用来交换两个元素）
  - 如果一个类定义了自己的 swap，那么算法将使用自定义版本；否则，算法将使用标准库定义的 std::swap
  - swap 并不是必要的，但是，对于分配了资源的类，定义 swap 可能是一种很重要的优化手段
  - 示例：swap 的典型实现
    ```C++
    class HasPtr
    {
    friend void swap(HasPtr &, HasPtr &);
    };
    
    inline void swap(HasPtr &lhs, HasPtr &rhs)
    {
        using std::swap;
        swap(lhs.ps, rhs.ps);  // 交换指针，而不是 string 数据
        swap(lhs.i, rhs.i);  // 交换 int 成员
    }
    ```
  
  - 注意：
    - swap 函数应该调用 swap，而不是 std::swap，即每个 swap 调用都应该是未加限定的
      - 如果存在特定类型的 swap 版本，其匹配程度会优于 std 中定义的版本（原因参见 16.3 节）
    - swap 函数中的 using 声明不会隐藏函数体中对特定版本 swap 的调用（原因参见 18.2.3 节）

- 在赋值运算符中使用 swap
  - `拷贝并交换`技术：定义了 swap 的类通常使用该 swap 来定义它们的（拷贝）赋值运算符
  - 示例：
    ```C++
    HasPtr & HasPtr::operator=(HasPtr rhs)  // 注意这里的参数不是引用
    {
        swap(*this, rhs);  // 这里会调用 HasPtr 的 swap 版本
        return *this;
    }
    ```
  - 注意：无论对浅拷贝的 shared_ptr 和引用计数形式的实现，还是对深拷贝的一般实现，该技术都是有效的
  - 备注：使用该技术的赋值运算符自动就是异常安全的，且能正确处理自赋值

---
## 13.4_拷贝控制示例

- [示例：](./examples/13/13.4/main.cc)

---
## 13.5_动态内存管理类

- 某些类需要自己进行内存分配
  - 这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存
- 注意：
  - 在重新分配内存的过程中移动而不是拷贝元素（可以提高效率）
  - 移动构造函数和 std::move
    - std::move 返回的结果是移动构造函数的参数
- [示例：实现标准库 vector 类的一个只用于 string 的简化版本，名为 StrVec](./examples/13/13.5/StrVec.h)

---
## 13.6_对象移动

- 对象移动（C++11 新标准）是新标准的一个最主要的特征
  - 适用场景：
    - 某些情况下，对象拷贝后就立即被销毁了，此时移动而非拷贝对象可以大幅提升性能
    - IO 类或 unique_ptr 包含不能被共享的资源，这样的类不能拷贝但可以移动
- 备注：
  - 标准库容器（C++11 新标准）、string 和 shared_ptr 类既支持移动也支持拷贝
  - IO 类和 unique_ptr 类可以移动但不能拷贝

### 13.6.1 右值引用

- 右值引用（C++11 新标准）
  - 一般形式：通过 `&&` 来获得右值引用
  - 含义：必须绑定到右值的引用
  - 目的：为了支持移动操作
  - 重要性质：只能绑定到一个**将要销毁**的对象（对象没有其他用户）
  - 备注：类似于**任何引用**，一个右值引用也不过是某个对象的另一个==名字==而已

- 左值引用与右值引用
  - 左值引用，不能绑定到
    - 要求转换的表达式
    - 字面常量
    - 返回右值的表达式
    - 备注：返回左值的函数，连同赋值、下标、解引用、前置递增/递减运算符，都是返回左值的表达式
  - 右值引用，与左值引用的绑定特性==完全相反==
    - 可以绑定到上述表达式上
    - 不能**直接**绑定到一个左值上
    - 备注：
      - 返回==非引用类型==的函数，连同算数、关系、位、后置递增/递减运算符，都生成右值
      - 右值要么是==字面常量==，要么是表达式求值过程中创建的==临时对象==
  - 备注：自此将常规引用改称为左值引用
  - 示例：
    ```C++
    int i = 42;
    int &r = i;  // 正确
    int &&rr = i;  // 错误：i 不能将一个右值绑定到一个左值上
    int &r2 = i * 42;  // 错误：i * 42 是一个右值
    const int &r3 = i * 42;  // 正确：可以将一个 const 引用绑定到一个右值上
    int &&rr2 = i * 42;  // 正确
    ```

- ==变量（表达式）是左值==
  - 变量可以看作只有一个运算对象而没有运算符的表达式
  - 因此，不能将一个右值引用绑定到一个==右值引用类型的变量==上（即使该变量是右值引用类型也不行）
  - 示例：
    ```C++
    int &&rr1 = 42;  // 正确：字面值常量是右值
    int &&rr2 = rr1;  // 错误：表达式 rr1 是左值
    ```

- 标准库 move 函数
  - 头文件：\<utility>
  - 作用：用来获得绑定到左值上的右值引用
  - 注意：
    - 对于一个移后源对象，可以直接销毁或赋予新值后使用，但无法再使用其旧值
    - 使用 move 的代码应该使用 std::move 而不是 move，这样可以避免潜在的名字冲突
  - 示例：
    ```C++
    int &&rr1 = 42;
    int &&rr3 = std::move(rr1);  // 正确
    ```

### 13.6.2 移动构造函数和移动赋值运算符

- 移动构造函数和移动赋值运算符
  - 作用：让自定义类型支持移动操作

- 移动构造函数
  - 一般形式：第一个参数是该类类型的==右值引用==；任何可能的额外参数，都必须有默认值
  - 注意：移后源对象必须是有效且可析构的
  - 示例：
    ```C++
    StrVec::StrVec(StrVec &&s) noexcept  // 表明该移动构造函数不会抛出任何异常
        : elements(s.elements), first_free(s.first_free), cap(s.cap)
    {
        // 令移后源对象 s 进入以下状态 -- 当它运行析构函数时是安全的
        // 如果没有将 s.first_free 设置为 nullptr，移后源对象在析构时就会释放掉已经转交给当前对象的资源
        s.elements = s.first_free = s.cap = nullptr;
    }
    ```

- 移动赋值运算符
  - 一般形式：与移动赋值运算符的唯一区别是参数列表中的唯一一个参数是该类类型的==右值引用==
  - 注意：
    - 移后源对象必须是有效且可析构的
    - 必须正确处理自赋值的情况（特别是右值可能是 move 调用返回的结果）
  - 示例：
    ```C++
    StrVec &StrVec::operator==(StrVec &&rhs) noexcept  // 表明该移动赋值运算符不会抛出任何异常
    {
        if (this != &rhs)  // 确保不是自赋值
        {
            free();  // 这里与拷贝赋值运算符不同，可以先直接释放已有元素
            // 开始接管资源
            elements = rhs.elements;
            first_free = rhs.first_free;
            cap = rhs.cap;
            rhs.elements = rhs.first_free = rhs.cap = nullptr;
        }
        return *this;  // 注意，这里返回的还是左侧运算对象的左值
    }
    ```

- 合成的移动操作
  - 触发条件：只有当一个类没有任何定义自定义版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为其合成移动构造函数或移动赋值运算符
  - 默认操作
    - 内置类型：可以直接移动内置类型的成员
    - 类类型：需要该类具有对应的移动操作
  - 备注：合成移动操作的条件与合成拷贝操作的条件大不相同
  - 注意：
    - 移动操作永远不会隐式定义为删除的
    - 如果显式要求编译器生成 `=default` 的移动操作，但是编译器不能移动所有成员，则编译器会将移动操作定义为删除的
      - 也就是这种情况下 `=default` 等价于 `=delete`
  - 备注：移动操作被定义为删除的原则
    - 移动构造函数被定义为删除的条件
      - 有类成员定义了自己的拷贝构造函数且未定义移动构造函数
      - 或，有类成员定义自己的拷贝构造函数且编译器不能为其合成移动构造函数
      - 或，有类成员的移动构造函数被定义为删除的或不可访问的
      - 或，该类的析构函数被定义为删除的或不可访问的
    - 移动赋值运算符被定义为删除的条件
      - 有类成员定义了自己的拷贝赋值运算符且未定义移动赋值运算符
      - 或，有类成员定义自己的拷贝赋值运算符且编译器不能为其合成移动赋值运算符
      - 或，有类成员的移动赋值运算符被定义为删除的或不可访问的
      - 或，有类成员是 const 的或是引用
  - ==注意：如果定义了一个移动构造函数或移动赋值运算符，则必须也定义自己的拷贝操作==
    - 因为，如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的==合成==拷贝构造函数和拷贝赋值运算符也会被定义为删除的

- 拷贝并交换赋值运算符和移动操作
  - 示例：使用==交换并赋值技术==的赋值运算符既是移动赋值运算符，也是拷贝赋值运算符
    ```C++
    class HasPtr
    {
    public:
        // 确保已经定义了移动构造函数
        HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) { p.ps = nullptr; }
        // 当实参是左值的时候，rhs 通过拷贝构造被初始化
        // 当实参是右值的时候，rhs 通过移动构造被初始化
        HasPtr & operator=(HasPtr rhs)  
        {
            swap(*this. rhs);
            return *this;
        } 
    };
    ```

- ==更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作==，包括
  - 拷贝构造函数
  - 拷贝赋值运算符
  - 移动构造函数
  - 移动赋值运算符
  - 析构函数

- 移动迭代器（C++11 新标准）
  - 本质：是一种迭代器适配器
  - 作用：移动迭代器的解引用运算符生成一个右值引用
    - 通过改变给定迭代器的解引用运算符的行为来适配此迭代器，
  - 用法：通过调用标准库函数 make_move_iterator 将一个普通迭代器转换为移动迭代器
  - 备注：原迭代器的所有操作在移动迭代器中都照常工作
  - 注意：标准库不保证哪些算法适用移动迭代器，哪些不适用
    - 因为移动一个对象可能会使得源对象失效，因此只有在确信算法在==为一个元素赋值==或==将其传递给一个用户定义的函数后不再访问它是==，才能将移动迭代器传递给算法
  - 示例：
    ```C++
    void StrVec::reallocate()
    {
        auto newcapacity = size() ? 2 * size() : 1;
        auto first = alloc.allocate(newcapacity);
        // 这里的源迭代器为移动迭代器
        // 对其进行解引用将生成右值引用
        // 这意味着 construct 将使用移动构造函数来构造元素
        auto last = unitialized_copy(make_move_iterator(begin()), 
                                     make_move_iterator(end()),
                                     first);
        free();
        elements = first;
        first_free = last;
        cap = elements + newcapacity;
    }
    ```

- 注意：
  - 移后源对象必须有效且可析构的
    - 可析构的：移动操作（移动构造函数和移动赋值运算符）并不会销毁移后源对象
      - 一旦完成移动，移后源对象必须不再指向被移动的资源
      - 移后源对象的在其作用域结束后，通过自身的析构函数销毁
    - 有效的：可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值
      - 使用指的是使用该对象，而不是该对象中的数据
        - 如果为移后源对象赋予了新值，就可以再次正常使用该对象
      - 因此，用户不能对移后源对象的值做任何假设
  - 移动操作、标准库容器和异常
    - 一般情况下，由于移动操作不分配任何资源，所以不会抛出异常
    - 除非标准库知道自定义的移动构造函数不会抛出异常，否则它会认为移动该类的对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作
      - 例如：对于 vector 来说，除非它知道元素类型的移动构造函数不会抛出异常；否则，在==重新分配内存==的过程中，就必须使用拷贝构造函数而不是移动构造函数
    - `noexcept`：表明该函数不会抛出任何异常（C++11 新标准）
      - 在构造函数中，noexcept 紧跟在参数列表后面（初始化开始的冒号前面）
      - 注意：必须在类的头文件声明和定义中都指定 noexcept
    - ==注意：不抛出任何异常的移动构造函数和移动赋值运算符必须标记为 noexcept（可以提高效率）==
  - 移动右值，拷贝左值：如果一个类既有移动构造函数，又有拷贝构造函数，则编译器使用普通的==函数匹配规则==确定使用哪个
    - 移动构造函数==只能==用于实参是右值的情形（精确匹配）
    - 拷贝构造函数可以用于任何可以转换为该类类型的类型
      - 即，如果类==没有移动构造函数==，右值也可以被拷贝（即使通过 move 来移动也是如此）
    - 备注：使用拷贝构造函数代替移动构造函数几乎肯定是安全的
      - 拷贝构造函数天生满足移动构造函数对移后源对象状态的要求
    - 示例1：
      ```C++
      StrVec v1, v2;
      v1 = v2;  // v2 是左值，使用拷贝赋值
      StrVec getVec(istream &); // getVec 返回一个右值（非左值引用，是个临时值，所以是右值）
      v2 = getVec(cin);
      ```
    - 示例2：
      ```C++
      class Foo
      {
      public:
        Foo() = default;
        Foo(const Foo&);  // 拷贝构造函数
        // 定义了拷贝构造函数，但未定义移动构造函数，所以移动构造函数是删除的
      };
      Foo x;
      Foo y(x);  // 拷贝构造函数
      Foo z(std::move(x));  // 拷贝构造函数，因为未定义移动构造函数
      ```
  - 不要随意使用移动操作（std::move）
    - 在类代码中小心地使用 move 可以大幅度提升性能
    - 在用户代码中使用，可能导致莫名其妙、难以查找的错误（没有把握，不要使用）

### 13.6.3 右值引用和成员函数

- 可以为成员函数同时提供拷贝和移动版本
  - 第一个版本：接受一个指向 const 的左值引用（const &T）
  - 第二个版本：接受一个指向非 const 的右值引用（&&T）
  - 备注：
    - 一般来说，不需要为函数操作定义接受一个 const &&T 和 &T 参数的版本
  - 示例：
    ```C++
    class StrVec
    {
    public:
        void push_back(const std::string &);
        void push_back(std::string &&);
    };

    void StrVec::push_back(const std::string &s)
    {
        chk_n_alloc();
        alloc.construct(first_free++, s);
    }

    void StrVec::push_back(std::string &&s)
    {
        chk_n_alloc();
        alloc.construct(first_free++, std::move(s));  // 这里需要通过 std::move 获得移动构造函数的参数
    }

    // 用法示例
    StrVec vec;
    string s = "Hello world!!!";
    vec.push_back(s);  // 调用 push_back(const std::string &)
    vec.push_back("Hi!!!");  // 调用 push_back(std::string &&)
    ```

- 右值和左值引用成员函数
  - 通常，可以在一个对象上调用成员函数，而==不管该对象是一个左值还是一个右值==
    - 示例：
      ```C++
      s1 + s2 = "wow!";  // 给一个右值赋值
      ```
  - 引用限定符（C++11 新标准）
    - 一般形式：
      - 对于 `&` 限定的成员函数，只能用于左值
      - 对于 `&&` 限定的成员函数，只能用于右值
      - 备注：
        - 限定符位于参数列表之后
        - 限定符可以与 const 一起使用，但需要位于 const 之后
        - 限定符必须==同时出现==在函数的声明和定义中
        - 限定符只能用于（非 static）成员函数
    - 作用：限定成员函数的隐式 this 指针指向的是一个左值还是右值
    - 示例：
      ```C++
      class Foo
      {
      public:
        Foo & operator=(const Foo &) &;  // 只能用于可修改的左值
      };

      Foo & Foo::operator=(const Foo &rhs) &
      {
          // 此处省略函数体
          return *this;
      }

      // 调用举例
      Foo &retFoo();  // 声明一个返回引用的函数
      Foo retVal();  // 声明一个返回值的函数
      Foo i, j;
      i = j;  // 正确：i 是左值
      retFoo() = j;  // 正确：retFoo 返回左值
      retVal() = j;  // 错误：retVal 返回右值
      i = retVal();  // 正确：可以将右值作为赋值操作的右侧运算对象（能够用来被拷贝、被移动）
      ```
    - 注意：如果不为成员函数指定引用限定符，那么该成员函数既可以用于左值，也可以用于右值
  - 重载和引用函数
    - 引用限定符也可以区分重载版本。并且，可以综合引用限定符和 const 来区分一个成员函数的重载版本
    - 注意：如果一个成员函数有==引用限定符==，那么同名函数==具有相同参数列表==的所有版本都必须有引用限定符
      - 因为没有引用限定符的版本，既可以用于右值，也可以用于左值，会导致二义性
    - 示例：
      ```C++
      class Foo
      {
      public:
        Foo & sorted() &&;  // 匹配非 const 的右值（如果需要匹配 const 的右值，需要再单独声明一个函数）
        Foo sorted() const &;  // 匹配 const 和 非 const 的左值（在没有非 const 版本成员函数的情况下）
      private:
        vector<int> data;
      };

      Foo & Foo::sorted() &&  // 这个函数不保证不对右值对象作出改变，所以直接改变就好
      {
          sorted(data.begin(), data.end());
          return *this;
      }

      Foo Foo::sorted() const &  // 这个函数保证不对左值对象作出改变，所以只能创建并返回副本
      {
          Foo ret(*this);  // 拷贝一个副本
          sorted(ret.data.begin(), ret.data.end());
          return ret;
      }
      ```
