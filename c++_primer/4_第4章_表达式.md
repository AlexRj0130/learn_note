[TOC]

# 第4章_表达式

- 表达式由==一个或多个==运算对象组成

---
## 4.1_基础

### 4.1.1 基本概念

- 运算符分类
  - 一元运算符：作用于一个运算对象
  - 二元运算符：作用于两个运算对象
  - 三元运算符：作用于三个运算对象（只有一个三元运算符）
  - 函数调用运算符：对运算对象的数量没有限制
  - 备注：对于一些既能作为一元运算符，也能作为二元运算符的符号，其实际意义由它所在的上下文决定（上下文不同，其意义完全不相干，完全可以作为不同的符号使用）

- 组合运算符和运算对象
  - 要理解含有多个运算符的复杂表达式，需要关注以下内容
    - 运算符的优先级
    - 运算符的结合律
    - 运算对象的求值顺序

- 运算对象转换：==对于二元运算符，往往要求运算对象类型相同==；即使不相同，只要能够转换成相同即可
  - 例如：小整数类型（bool, char, short）往往被**提升**为 int 型

- 重载运算符：当运算符作用于类类型的运算对象时，由用户自定义其含义
  - 用户==可以自定义==运算对象的类型和返回值的类型
  - 用户==无法自定义==运算对象的个数，运算符的优先级和结合律

- 左值和右值（C++ 与 C 语言对此有所区别）
  - 当一个对象被用作右值的时候，用的是该对象的值（内容）
  - 当一个对象被用作左值的时候，用的是该对象的身份（内存中的位置）
  - 注意：左值可以作为右值使用（只使用值，不用身份）；但==反过来不行==
  - 左值应用场景举例
    - 赋值运算符：左侧运算对象为左值
    - 取地址符：运算对象必须为左值
    - 以下运算符的求值结果为左值
      - 内置解引用运算符
      - 下标运算符
      - 迭代器解引用运算符
      - string 和 vector 的下标运算符
      - 前置版本的递增、递减运算符
    - 内置类型和迭代器的递增递减运算符：运算对象必须为左值
  - ==decltype==关键字
    - 如果表达式的求值结果是左值，decltype 作用于该表达式得到一个==引用==类型
    - 例如：假定 p 的类型是 int *，则
      - decltype(*p) 的结果是 &int
      - decltype(&p) 的结果是 int **

### 4.1.2 优先级和结合律

TODO: 与 C 基本一致，暂略

### 4.1.3 求值顺序

- 大多数情况下，不会明确指定求值的顺序
- 有 4 种运算符明确规定了运算对象的求值顺序
  - `a&&b`：先对 a 求值，只有 a 的求值结果为真，才继续对 b 求值
  - `a||b`：先对 a 求值，只有 a 的求值结果为假，才继续对 b 求值
  - `a?b:c`：先对 a 求值，若 a 的求值结果为真，则对 b 求值；否则，对 c 求值
  - `a,b`：从左向右依次求值（并将最后一个求值结果作为表达式的值）

- 注意：==运算对象的求值顺序与优先级和结合律无关==
  - 例如：f() + g() * h() + j()
    - 优先级规定：g() 的返回值和 h() 的返回值相乘
    - 结合律规定：f() 的返回值先和 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加
    - 其值顺序表明：这些函数的调用顺序未知
- 建议：
  - 拿不准的时候，用括号强制明确表达式的组合关系
  - 如果改变了某个运算对象的值，那么在表达式的其他地方不要再使用该运算对象

---
## 4.2_算数运算符

- 一元运算符：+, -, 
- 二元运算符：*, /, %, +, -

- 备注：
  - 均满足左结合律
  - 运算对象和求值结果==都是右值==

- 注意：
  - 如果发生溢出，很多编译器和运行时是不会报错的，所以结果未定义
  - 对于除法运算，商一律向 0 取整（即直接切除小数部分，C++11 新标准）
    - (-m)/n == m/(-n) == -(m/n)
  - 对于求余运算（C++11 新标准）
    - m%(-n) == m%n
    - (-m)%n == -(m%n)

---
## 4.3_逻辑和关系运算符

- 关系运算符：作用于算数类型或指针类型
- 逻辑运算符：作用于任意能转换成布尔值的类型

- 注意：进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象
  - 示例：
    ```C++
    if (val == true)  // 如果 val 是整型，这种用法，会导致 true 被转换为 1 再与 val 进行比较
    ```

TODO: 余与 C 基本一致，暂略

---
## 4.4_赋值运算符

- 赋值运算符
  - ==右结合律==
  - ==优先级较低==
  - 左侧的运算对象必须是一个==可修改的左值==
  - 求值结果是它的左侧运算对象（且结果为左值）
    - 如果赋值运算符左右两个运算对象的类型不同，则右侧运算对象将转换成左侧运算对象的类型 
  - 可以使用花括号括起来的初值列表作为赋值语句的右侧运算对象（C++11 新标准）
  - 对于类类型，赋值运算的细节由类本身决定

- 复合赋值运算
  - 每种运算符都有相应的复合赋值形式
    - 算数运算符：`+=`, `-=`, `*=`, `/=`, `%=`
    - 位运算符：`<<=`, `>>=`, `&=`, `^=`, `|=`
  - 等价于 `a = a op p`
  - 区别在于：==左侧运算对象的求值次数==
    - 复合赋值运算：求值一次（性能好一点）
    - 赋值运算：求值两次（性能差一点）

---
## 4.5_递增和递减运算符

- 必须为==左值==运算对象
- 返回值
  - 前置版本：返回运算对象本身
  - 后置版本：返回运算对象的副本

TODO: 余与 C++98 基本一致，暂略

---
## 4.6_成员访问运算符

- `.`运算符：
  - 作用：获取类的一个成员
  - 返回值：
    - 运算对象为左值，则返回值为左值
    - 运算对象为右值，则返回值为右值
- `->`运算符：
  - 作用：ptr->mem 等价于 (*ptr).mem
  - 返回值：左值（解引用的返回值为左值）

---
## 4.7_条件运算符

- `cond ? expr1 : expr2`
  - 作用：将简单的 if-else 逻辑嵌入单个表达式中
  - 返回值：
    - 当条件运算符的两个表达式都是左值，或者能转换成同一种左值类型时，返回值为左值；
    - 否则，返回值为右值
  - 示例1：嵌套条件运算符
    ```C++
    finalGrade = (grade > 90) ? "high pass"
                              : (grade < 60) ? "fail" : "pass";
    ```
    - 备注：条件运算符满足右结合律，所以靠右边的条件运算构成了靠左边的条件运算的分支
  - 示例2：条件运算符的优先级非常低（以输出表达式作为对比）
    ```C++
    cout << ((grade < 60) ? "fail" : "pass");  // 输出 pass 或 faile
    cout << (grade < 60) ? "fail" : "pass";  // 输出 1 或者 0
    cout << grade < 60 ? "fail" : "pass";  // 错误：试图比较 cout 和 60
    ```

---
## 4.8_位运算符

- 位运算符：`~`, `<<`, `>>`, `&`, `^`, `|`
  - 作用于==整数类型==的运算对象
  - 将运算对象看做==二进制位==的集合
  - 如果运算对象是==小整型==，则会被自动提升成较大的整型
  - 运算对象可以带符号，也可以不带符号
    - 对于如何处理带符号运算对象的符号位，依赖于具体机器
    - 建议：==仅将位运算符用于处理无符号类型==

- `<<`, `>>`：移位运算符
  - 右侧运算对象不能为负
  - 右侧运算对象必须严格==小于==结果（可能把左侧运算对象进行了提升）的位数，否则结果未定义
  - 移出边界的位会被舍弃
  - 对于左移运算：直接补0（无论左侧运算对象是否带符号）
  - 对于右移运算：
    - 左侧运算对象不带符号：直接补0
    - 左侧运算对象带符号：与具体环境有关

- `~`：按位取反运算符
  - 小整型提升成大整形（只需要把高位补0即可，原对象对应的低位保持不变）

- `&`, `|`, `^`：按位与、或、异或运算符

---
## 4.9_sizeof运算符

- 返回一条表达式或一个类型所占的字节数
- 满足右结合律
- 返回值的类型为 size_t（可以作为==常量表达式==）
- 注意：sizeof 并不实际计算其运算对象的值（而是求其所占内存空间的字节数）

- sizeof 运算符的结果部分地依赖于其作用的类型
  - sizeof(char 或者 类型为 char 的表达式)，结果为 1
  - sizeof(引用)，结果为被引用对象所占内存空间的大小
  - sizeof(指针)，结果为指针本身所占内存空间的大小
  - sizeof(解引用指针)，结果为指针所指对象所占内存空间的大小
    - 在 sizeof 的运算对象中解引用一个无效指针是安全的（因为指针并没有被真正使用） 
  - sizeof(数组)，结果为整个数组所占内存空间的大小
  - sizeof(string 或 vector)，结果为类型的==固定部分==的大小，不会计算对象中的元素占用了多少空间

---
## 4.10_逗号运算符

TODO: 与 C 基本一致，暂略

---
## 4.11_类型转换

- 如果两种类型可以互相转换（替代），那么它们就是关联的

- 隐式转换：由编译器自动执行，无须程序员介入
  - 触发场景：
    - 整型提升：比 int 类型小的整型提升为较大的整数类型（大小指的是所占内存空间的大小）
    - 条件表达式中：非布尔值转换为布尔类型
    - 初始化过程中：初始值转换成变量的类型
    - 赋值语句中：右侧运算对象转换为左侧对象的类型
    - 如果算数运算或关系运算的运算对象有多种类型，需要转换成同一类型
    - 函数调用时也会发生类型转换
  - 算数类型的隐式转换：被设计得尽可能避免损失精度

### 4.11.1 算数转换

- 转换原则：尽可能保持精度
  - 把运算符的运算对象转换成运算对象中最宽（占用内存空间最大）对象的类型
  - 表达式中既有==浮点==类型又有==整数==类型时，整数值转换为相应的浮点值
- 具体转换步骤
  - 整型提升：把小整数类型转换成较大的整数类型
    - 只要 bool, char, signed char, unsigned char, short, unsigned short 等所有可能的值都可以存在 int 中，就提升成 int 型
    - 把较大的 char(wchar_t, char16_t, char32_t) 提升成 int, unsigned int, long, unsigned long, long long, unsigned long long 中大小足够且最小的一种类型
  - 如果提升后的运算对象同号
    - 类型不一致，则较小的类型转换为较大的类型
    - 类型一致，无需进一步转换
  - 如果提升后的运算对象异号
    - 无符号类型==不小于==带符号类型：带符号类型转换为无符号类型（注意==带符号负数==的转换规则）
    - 无符号类型==小于==带符号类型：结果依赖于机器
      - 如果无符号类型的所有值都能存在该带符号类型中：无符号类型转换成带符号类型
      - 否则，带符号类型转换成无符号类型
  - 示例：
    ```C++
    3.14159L + 'a';  // 'a' 提升成 int, int 再转换为 long double
    doubleVal + intVal;  // intVal 转换为 double
    doubleVal + floatVal;  // floatVal 转换成 double
    intVal = doubleVal;  // doubleVal 转换成 int
    boolFlag = doubleVal;  // doubleVal 转换成 bool
    charVal + floatVal;  // charVal 提升成 int, int 再转换为 float
    shortVal + charVal;  // shortVal 和 charVal 都提升成 int
    charVal + longVal;  // charVal 转换为 long
    intVal + unsignedLongVal;  // intVal 转换为 unsigned long
    unsignedShortVal + intVal;  // 根据 unsigned short 和 int 所占空间的大小进行提升
    unsignedIntVal + longVal;  // 根据 unsigned int 和 long 所占空间的大小进行提升
    ```

### 4.11.2 其他隐式类型转换

- 数组转换成指针：数组自动转换成指向数组首元素的指针
  - decltype, &(取地址符), sizeof, typeid 除外
- 指针的转换
  - 常量整数值 0，字面值 nullptr 可以转换为任意指针类型
  - 指向任意==非常量==的指针能转换为 void *
  - 指向任意==对象==的指针能转换为 const void *
  - 指向非常量类型的指针转换为对应常量类型的指针（但反过来不行；引用同理）
- 转换成布尔类型
  - 如果指针或算数类型的值为 0， 转换结果为 false
  - 否则，转换结果为 true
- 类类型定义的转换
  - 如何转换由类类型自行定义
  - 编译器每次只能执行一种类类型的转换

### 4.11.3 显式转换

- 又称==强制类型转换==：只有在不得不用时才用（因为非常危险）
- `static_cast`：
  - 作用：定义明确的类型转换
  - 限制条件：被转换对象==不包含底层 const==
  - 示例1：
    ```C++
    double slope = static_cast<double>(j) / i;
    ```
  - 示例2：
    ```C++
    void *p = &d;
    double *dp = static_cast<double *>(p);
    ```
- `const_cast`: 
  - 作用：去掉 const 性质
  - 限制条件：只能改变被转换对象的==底层 const==
  - 注意：
    - 如果对象本身不是一个常量，使用强制类型转换==获得写权限==是合法的行为；
    - 否则，结果未定义
  - 示例：
    ```C++
    const char *cp;
    char *q = static_cast<char *>(cp);  // 错误：cp 包含底层 const
    static_cast<string>(cp);  // 正确：字符串字面值转换成 string 类型
    const_cast<string>(cp);  // 错误：const_cast 值改变常量属性（不改变类型）
    ```
- `reinterpret_cast`: 
  - 作用：为运算对象的==位模式==提供==较低层次上的重新编译==（让编译器重新理解这块内存的类型）
  - 注意：该转换非常危险，因为编译器认识的类型改变了
  - 示例：
    ```C++
    int *ip;
    char *pc = reinterpret_cast<char *>(ip);
    ```
- `dynamic_cast`:（见19.2节）

- 建议：
  - 强制类型转换会干扰正常的类型检查，所以强烈建议少用
  - 特别是 reinterpret_cast，更应该少用（最危险）
  - 有重载函数的上下文中可以因情况使用 const_cast
  - 尽量不要使用旧式（C 或 C++98）的强制类型转换

---
## 4.12_运算符优先级表

| 优先级 | 运算符 | 结合律 | 功能 | 用法 |
| :---: | :---: | :---: | :---: | :---: |
| 1 | :: | 左 | 全局作用域 | ::name |
| ^ | :: | 左 | 类作用域 | class::name |
| ^ | :: | 左 | 命名空间作用域 | namespace::name |
| 2 | . | 左 | 成员选择 | object.member |
| ^ | -> | 左 | 成员选择 | pointer->member |
| ^ | [] | 左 | 下标 | expr[expr] |
| ^ | () | 左 | 函数调用 | name(expr_list) |
| ^ | () | 左 | 类型构造 | type(expr_list) |
| 3 | ++ | ==右== | 后置递增运算 | lvalue++ |
| ^ | -- | ==右== | 后置递减运算 | lvalue-- |
| ^ | typeid | ==右== | 类型ID | typeid(type) |
| ^ | typeid | ==右== | 运行时类型ID | typeid(expr) |
| ^ | explicit cast | ==右== | 类型转换 | cast_name\<type>(expr) |
| 4 | ++ | ==右== | 前置递增运算 | ++lvalue |
| ^ | -- | ==右== | 前置递减运算 | --lvalue |
| ^ | ~ | ==右== | 按位求反 | ~expr |
| ^ | ! | ==右== | 逻辑非 | !expr |
| ^ | - | ==右== | 一元负号 | -expr |
| ^ | + | ==右== | 一元正号 | +expr |
| ^ | * | ==右== | 解引用 | *expr |
| ^ | & | ==右== | 取地址 | &lvalue |
| ^ | () | ==右== | 类型转换 | (type)expr |
| ^ | sizeof | ==右== | 对象的大小 | sizeof expr |
| ^ | sizeof | ==右== | 类型的大小 | sizeof(type) |
| ^ | Sizeof... | ==右== | 参数包的大小 | Sizeof...(name) |
| ^ | new | ==右== | 创建对象 | new type |
| ^ | new[] | ==右== | 创建数组 | new type[size] |
| ^ | delete | ==右== | 释放对象 | delete expr |
| ^ | delete[] | ==右== | 释放数组 | delete[] expr |
| ^ | noexcept | ==右== | 能否抛出异常 | noexcept(expr) |
| 5 | ->* | 左 | 指向成员选择的指针 | ptr->*ptr_to_member |
| ^ | .* | 左 | 指向成员选择的指针 | obj.*ptr_to_member |
| 6 | * | 左 | 乘法 | expr * expr |
| ^ | / | 左 | 除法 | expr / expr |
| ^ | % | 左 | 取模（取余） | expr % expr |
| 7 | + | 左 | 加法 | expr + expr |
| ^ | - | 左 | 减法 | expr - expr |
| 8 | << | 左 | 向左移位 | expr << expr |
| ^ | >> | 左 | 向右移位 | expr >> expr |
| 9 | < | 左 | 小于 | expr < expr |
| ^ | <= | 左 | 小于等于 | expr <= expr |
| ^ | '>' | 左 | 大于 | expr > expr |
| ^ | >= | 左 | 大于等于 | expr >= expr |
| 10 | == | 左 | 相等 | expr == expr |
| ^ | != | 左 | 不相等 | expr != expr |
| 11 | & | 左 | 按位与 | expr & expr |
| 12 | '^' | 左 | 按位异或 | expr ^ expr |
| 13 | \| | 左 | 按位或 | expr \| expr |
| 14 | && | 左 | 逻辑与 | expr && expr |
| 15 | \|\| | 左 | 逻辑或 | expr \|\| expr |
| 16 | ?: | ==右== | 条件 | expr ? expr : expr |
| 17 | = | ==右== | 赋值 | lvalue = expr |
| 18 | *=, /=, %= | ==右== | 复合赋值 | lvalue += expr 等 |
| ^  | +=, -= | ==右== | ^ | ^ |
| ^  | <<=, >>= | ==右== | ^ | ^ |
| ^  | &=, \|=, ^= | ==右== | ^ | ^ |
| 19 | throw | ==右== | 抛出异常 | throw expr |
| 20 | , | 左 | 逗号 | expr, expr |