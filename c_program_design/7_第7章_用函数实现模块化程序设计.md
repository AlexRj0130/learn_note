[TOC]

# 第7章 用函数实现模块化程序设计

---
## 7.1 为什么要用函数

- 函数（即功能）
  - 每个函数用来实现一个==特定的功能==；
  - 函数的名字应反映其代表的功能。
- 函数的分类
  - 从用户使用的角度进行分类
    - 库函数：由系统提供，用户无须定义即可直接使用；
    - 自定义函数：用户自行定义的函数。
  - 从函数的形式角度进行分类
    - 无参函数：调用时无须向函数传递参数；
    - 有参函数：调用时需要向函数传递参数。

> - 关键在于**模块化程序设计**
>   - 在程序设计中药善于利用函数，以减少重复编写程序段的工作量。 

> 注：
>   - 一个 C 程序由一个或多个程序模块组成；每个程序模块作为一个源程序文件；每个源文件由一个或多个函数以及其他有关内容（如指令、数据声明与定义等）组成；
>   - ==源程序文件==是==编译单位==；
>   - main 函数时程序执行的入口；
>   - 程序中的所有函数是相互独立的；定义函数时是分别进行、互相独立的；
>     - 函数不能嵌套定义；
>     - 函数可以相互调用，但不能调用 main 函数；
>     - main 函数由操作系统调用。

---
## 7.2 怎样定义函数

### 7.2.1 为什么要定义函数

- 定义函数时应包括的内容：
  - 函数名；
  - 函数返回值的类型（即函数的类型）；
  - 函数参数的名字和类型（无参函数不需要这项）；
  - 函数的功能（在函数体中实现）。

> 注：
> - 所有函数，必须“先定义，后使用”；
> - 在头文件中应包含对==函数的声明==。

### 7.2.2 定义函数的方法

- 定义无参函数
  - 一般形式：类型名 函数名() { 函数体 }
- 定义有参函数
  - 一般形式：类型名 函数名(形式参数列表) { 函数体 }
- 定义空函数
  - 一般形式：类型名 函数名() {}

> 注：
>   - 函数体包括==声明==部分和==语句==部分；
>   - 空函数用来占位，以便在将来对该函数进行完善（在程序设计中常常被用到）。

---
## 7.3 调用函数

### 7.3.1 函数调用的形式

- 函数调用
  - 一般形式：函数名(实参列表)
- 函数调用的具体分类（按函数调用在程序中出现的形式和位置进行划分）
  - 函数调用语句
    - 特点
      - 不要求函数带回返回值；
    - 示例：printf("Hello world\n");
  - 函数表达式
    - 特点
      - 函数调用出现在另一个表达式中；
      - 要求函数带回返回值，以便参加表达式运算；
    - 示例：c = 2 * max(a, b);  // 最后的分号是表达式的分号，而不是 max 函数的分号
  - 函数参数
    - 特点
      - 函数调用作为另一个函数调用的实参；
      - 要求被调用函数带回返回值；
    - 示例：m = max(a, max(b, c));
  - > 关于分号：
    > - 函数调用语句需要分号；
    > - 函数表达式或函数参数不需要分号。

### 7.3.2 函数调用时的数据传递

- 形式参数和实际参数
  - 形式参数（又称“形参”，“虚拟参数”）
    - 在==定义函数==时函数名后面括号中的==变量名称==（就是个形式，没有占用内存）。
  - 实际参数（又称“实参”）
    - 在==调用函数==时，函数名后面括号中的参数（实际占有内存）。
    - > 实参可以是常量、变量或表达式，但必须有==确定的值==。

- 实参和形参间的数据传递
  - 在==函数调用==过程中，系统会把==实参的值==传递给被调用函数的形参；
    - 该值尽在函数调用期间有效；
    - 采用的是==按值传递==方式；
    - 只能由实参传给形参，即==单向传递==。
  - 实参与形参的类型应该==相同或赋值兼容==。

- [例7.2](./examples/7.2.c)

### 7.3.3 函数调用的过程

- 在函数被调用前，函数的形参并不占用内存单元（程序栈尚未建立）；
- ==按值传递==实参的值给形参；
- 函数执行期间，使用形参的值；
- 通过 return 语句将函数值返回给调用函数；
  - 如果函数不需要返回值，则不需要 return 语句（函数应定义为 void 类型）。
- 函数调用结束，形参被释放（程序栈被释放）。

### 7.3.4 函数的返回值

> 函数的返回值即函数的值。

- 函数的返回值通过函数中的 return 语句获得；
  - 如果需要从被调用函数带回一个值，则必须包含 return 语句；否则，可以不包含该语句；
  - 一个函数可以有一个以上的 return 语句，执行到哪一个 return 语句，哪一个 return 语句就起作用（函数从该处退出，函数栈被销毁）；
  - return 语句后面的括号可以不要（return z; 与 return (z); 等价）。
- 函数值的类型
  - 函数的返回值应属于某一个确定的类型；
  - 需要与 return 语句中的表达式类型保持一致（或类型兼容）；
  - 如果与 return 语句中的表达式类型不一致，则以函数类型为准。
  - > 对于数值型数据，系统会==自动进行类型转换==。

---
## 7.4 对被调用函数的声明和函数原型

- 在一个函数中调用另一个函数（即被调用函数）需要具备如下条件：
  - 被调用函数必须是已经定义的函数（例如库函数或用户自定义函数）；
  - 如果使用库函数，则应该在本文件开头用 #include 指令包含相关的函数库信息；
  - 如果使用用户自定义函数，并且被调用函数定义在了主调用函数后面，那么应该在主调用函数中对被调用函数进行==声明==。
  > - 如果已在文件的开头（所有函数之前），已对本文件中所调用的函数进行了声明，则在各函数中不必对其所调用的函数再做声明;
  > - 函数名、函数类型、参数个数、参数顺序必须与==函数声明==一致；
  > - 实参类型必须与==函数声明==中的形参类型相同（或赋值兼容）。

- 函数原型（函数声明）的一般形式（两种）
  - 函数类型 函数名(参数类型1 参数名1，参数类型2 参数名2，...，参数类型n 参数名n);
  - 函数类型 函数名(参数类型1，参数类型2，...，参数类型n);
  > - 第2中形式更加精炼，第1种形式==不易出错，并且参数意义明确，有利于理解程序==;
  > - 函数声明比定义中的行首多一个分号。

- [例7.4](./examples/7.4.c)

---
## 7.5 函数的嵌套调用

- 函数的嵌套调用：就是在定义一个函数的时候，又调用了另一个函数。

> C 语言不允许嵌套定义，但允许嵌套调用。

- [例7.5](./examples/7.5.c)

---
## 7.6 函数的递归调用

- 函数的递归调用：就是在调用一个函数的过程中，又出现==直接或间接==地调用==该函数本身==。
  - 直接调用：f1函数在函数体内直接调用f1；
  - 间接调用：f1函数在函数体内调用f2函数，f2函数在函数体内调用f1函数。

> 不应出现无终止的递归调用，而只应出现有限次数的、有终止的递归调用；
> C 语言的特点之一就是允许函数的递归调用。

- [例7.6](./examples/7.6.c)
- [例7.7](./examples/7.7.c)
- [例7.8](./examples/7.8.c)

---
## 7.7 数组作为函数参数

### 7.7.1 数组元素作函数实参

- 数组元素：可以作函数==实参==
  - 传递的是数组元素的值
  - > 形参在函数被调用时才会分配临时的存储单元。

- [例7.9](./examples/7.9.c)

### 7.7.2 数组名作函数参数

- 数组名：可以作函数==实参和形参==
  - 传递的是数组==第一个元素的地址==；
  - > 编译系统不检查新参数组（第一维）的大小，
    - 因此在定义函数时，可以不指定形参数组的大小
    - 例如：float average(float array[]) {...}

- [例7.10](./examples/7.10.c)
- [例7.12](./examples/7.12.c)

### 7.7.3 多维数组名作函数参数

- 多维数组名：可以作函数==实参和形参==
  - 可以指定每一维的大小
  - 也可以忽略第一维的大小（其他维不能忽略）

- [例7.13](./examples/7.13.c)

---
## 7.8 局部变量和全局变量

- 变量的作用域：变量在什么范围内有效；
> 从变量的作用域角度，可以将变量分为局部变量和全局变量。

### 7.8.1 局部变量

- 局部变量
  - 在函数的开头定义
    - 仅在本函数内有效
  - 在函数内的复合语句内定义
    - 仅在本复合语句范围内有效

> 注：
>   - 不同函数中可以使用相同的局部变量名；
>   - 函数的形参也是局部变量；

### 7.8.2 全局变量

- 全局变量
  - 在函数的外部定义
    - 从定义变量的位置到当前源文件结束之间有效

> 注：
>   - 设置全局变量的作用是增加函数间数据联系的渠道；
>   - 习惯上，将全局变量的第一个字母大写（非规定）；
>   - 全局变量在程序运行的全部过程中都会占用存储单元；
>   - 全局变量会使函数的通用性降低（不符合高内聚、低耦合的设计原则）；
>   - 全局变量会降低程序的清晰性。

---
## 7.9 变量的存储方式和生存期

### 7.9.1 动态存储方式与静态存储方式

- 静态存储方式
  - 具体解释：
    - 程序运行期由系统分配固定的存储空间；
    - 程序开始时分配，程序执行完毕后释放；
  - 生存期：程序运行期间；
  - 存放的数据类型：
    - 全局变量

- 动态存储方式
  - 具体解释：
    - 程序运行期根据需要进行动态的分配存储空间；
    - 函数调用开始时分配，函数结束后释放；
  - 生存期：函数调用期间；
  - 存放的数据类型：
    - 函数的形式参数；
    - 函数中的局部变量（自动变量，没有用 static 关键字声明）；
    - 函数调用时的现场保护和返回地址等。

> C 语言中，每个变量和函数都有两个属性：数据类型（如整型、浮点型等）和数据的存储类别（如静态存储和动态存储）。

### 7.9.2 局部变量的存储类别

> - C 的存储类别共 4 种：
>   - 自动的（auto）;
>   - 静态的（static）;
>   - 寄存器的（register）;
>   - 外部的（extern）
> - 根据变量的存储类别，可以知道变量的==作用域==和==生存期==。

- 自动变量（auto 变量）
  - 对应的数据：
    - 函数中定义的局部变量（不用 static 声明）;
    - 函数的形参。
  - 存储方式：动态存储；
  - 作用域：当前函数；
  - 特点：
    - 如果定义时没有指定初值，则其值不确定；
    - 运行时赋初值，即每调用函数一次，重新赋一次初值。
  - > auto 为默认，故可省略。
- 静态局部变量（static 局部变量）
  - 对应的数据：
    - 函数中用 static 定义的变量；
  - 存储方式：静态存储；
  - 作用域：当前函数；
  - 特点：
    - 如果定义时没有指定初值，则由编译器自动赋初值为 0；
    - 只在==编译时==赋初值（只赋初值一次），在程序运行时已经有初值，因此运行过程中不会赋初值;
    - 函数调用结束后不会消失，而继续保留原值（函数结束前的值）;
    - 虽然存储在静态存储区，但是作用域为当前函数，也就是只能被当前函数引用。
  - > 若非必要，不要多用静态局部变量（占用内存，降低可读性）。
  - [例7.16](./examples/7.16.c)
  - [例7.17](./examples/7.17.c)
- 寄存器变量（register 变量）
  - 对应的数据：
    - 函数中定义的局部变量（用 register 声明）
  - 作用域：当前函数
  - 存储方式：寄存器存储；
  - 生存期：函数调用期间；
  - 特点：
    - 将局部变量的值存放在 CPU 的寄存器中（而不是内存中）；
    - 实际上用 register 声明变量的必要性不大（编译器能够判断变量是否被频繁使用，然后自动做这件事儿）。

> 函数的形式参数可以定义为自动变量或寄存器变量。

### 7.9.3 全局变量的存储类别

- 全局变量
  - 对应的数据
    - 函数外声明的变量
  - 存储方式：静态存储
  - ==作用域==
    - 文件内：可以变量的定义点之前，通过 extern 关键字引用指定外部变量（将变量的作用域拓展到文件中的当前位置），[例7.18](./examples/7.18.c)；
    - 其他文件：在一个文件中定义外部变量，在另一个文件中通过 extern 关键字引用该外部变量（将变量的作用域拓展到其他文件）；
    - ==限定在当前文件==：在定义外部变量时添加 static 声明
      - 这样就无法在其他文件通过 extern 关键字访问到该变量;
      - 即使多个文件中包含同名的外部变量，只要使用 static 进行了声明，就不会混淆。

> 注意区分 static 修饰局部变量和全局变量时的不同效果。

---
## 7.10 关于变量的声明和定义

- 变量的声明
  - 定义性声明（简称定义）
    - 建立存储空间
    - 例如：int a;
  - 引用性声明
    - 不建立存储空间
    - 例如：extern int a;
  > - 广义的：声明包括定义，但并非所有的声明都是定义；
  > - 狭义的：建立存储空间的称为定义；否则，称为声明。

> 注：对于外部变量：
>  - 只能定义一次；
>  - 可以声明多次。 

---
## 7.11 内部函数和外部函数

### 7.11.1 内部函数

- 内部函数（又称静态函数）：只能被==本文件==中的其他函数调用；
  - 声明方法：在函数名和函数类型的前面加 static；
  - 声明形式：static 类型名 函数名(形参表);
  > - 为了提高程序的可靠性，通常把只能由本文件使用的函数和外部变量放在文件的开头，并都用 static 使之局部化。

### 7.11.2 外部函数

- 外部函数：可以被其他文件调用；
  - 声明方法：在函数名和函数类型的前面加 extern；
  - 声明形式：extern 类型名 函数名(形参表);
  > - 在其他文件中调用外部函数时，需要先对函数用 extern 做出声明；
  > - C 语言规定，如果定义函数时省略 extern，则默认为外部函数；
  > - C 语言允许在声明函数时省略 extern;
  > - 考虑到预处理器对 #include 头文件的处理方式，则可以理解外部函数是如何被引用的了。
