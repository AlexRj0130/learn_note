[TOC]

# 第三章 语义陷阱

## 3.1 指针与数组

- C 语言中指针与数组这两个概念之间的联系是密不可分的
- 数组
  - C 语言中只有一维数组
  - 数组的大小必须在编译期作为一个常数确定下来
  - 数组中的元素可以是任何类型的对象（包括数组）
  - 任何一个数组下标运算都等同于一个对应的指针运算（完全可以根据指针行为定义数组下标的行为）
- 指针
  - 给一个指针加上一个整数，与给该指针的二进制表示加上同样的整数，两者的含义截然不同
  - 指向同一数组中不同元素的两个指针相减，结果为指针间相差的元素个数
- 数组与指针
  - 数组名除了被用作 sizeof 的参数时表示整个数组，其他所有的情形中数组名都代表指向该数组中下标为 0 的元素的指针
- 示例
  ```C
  // 二维数组
  int calendar[12][31];
  int i;

  // 三种等价形式
  i = calendar[4][7];
  i = *(calendar[4] + 7);
  i = *(*(calendar + 4) + 7);

  // 数组指针
  int (*p)[31];
  p = calendar;
  ```

## 3.2 非数组的指针

- C语言中，字符串常量代表了一块内存区域的地址，其中的内容为字符串的所有字符和一个空字符`'\0'`。
- 示例
  ```C
  // 假设有两个字符串 s 和 t，将它们连接成单个字符串 r
  char *r, *malloc();
  r = malloc(strlen(s) + strlen(t));
  strcpy(r, s);
  strcat(r, t);
  // 错误1：malloc 可能无法提供请求的内存
  // 错误2：malloc 分配的内存要手动释放
  // 错误3：分配的大小不对，应该是 strlen(s) + strlen(t) + 1，原因是 strlen() 返回的字符数中不包括结尾的空字符
  ```

## 3.3 作为参数的数组声明

- 如果使用数组名作为函数参数，那么数组名会被转换为指向该数组第1个元素的指针
- 但并不是任何情况下该转换都会发生，例如
  ```C
  // 以下两者是不等价的
  extern char * hello;
  extern char hello[];
  ```

## 3.4 避免“举隅法”

- 不要混淆指针与指针所指向的数据
- 复制指针并不同时复制指针所指向的数据
- > 注：试图修改字符串常量的行为是未定义的

## 3.5 空指针并非空字符串

- 绝不能解引用一个空指针
- 当常数 0 被转换为指针时，该指针为空指针
- 编译器保证空指针绝不等于任何有效地指针

## 3.6 边界计算与不对称边界

- 在 C 语言中，如果声明一个数组的大小为 n，则其中元素的下标范围为 `0` 至 `n - 1`
- 不对称边界：
  - 下界：范围内的第一个元素的下标
  - 上界：范围内的最后一个元素的下标加 1
  - 元素个数：上界 - 下界
  - 元素个数为0：上界 等于 下界
  - > 上界永远不可能小于下界
- ANSIC 标准允许规定：数组中实际不存在的“溢界”元素的地址位于数组所占内存之后，这个地址可以用于进行赋值和比较（但不允许引用）
  ```C
  void bufwrite(char *p, int n)
  {
      while(--n >= 0)
      {
          if (bufptr == &buffer[N])
            flushbuffer();
          *bufptr++ = *p++;  // 等价于 *(bufptr++) = *(p++);
      }
  }
  ```

## 3.7 求值顺序

- C 语言中的某些运算符总是以一种已知的、规定的顺序来对其操作数进行求值，而另外一些则不是这样
- C 语言中只有四个运算符（ &&、||、?: 和 ,）存在规定的求值顺序
  - && 和 ||：先对左侧操作数求值，只有再需要时才对右侧操作数求值
  - a?b:c：先对 a 求值，根据 a 的求值结果再对 b 或 c 求值
  - ,：先对左侧操作数求值（丢弃求值结果），再对右侧操作数求值
- > C 语言中==其他所有运算符==对其操作数求值的顺序是未定义的
- 示例：
  ```C
  int i;
  while (i < n)
  {
      y[i++] = x[i];  // 结果未定义
  }
  ```

## 3.8 运算符&&、||和!

- C 语言中的位运算符（&、|、~）和逻辑运算符（&&、||、!）某些时候可以互换（纯属巧合，不能使用）
- 示例：
  ```C
  i = 0;

  while (i < tabsize && tab[i] != x) i++;
  // 巧合于
  while (i < tabsize & tab[i] != x) i++;

  // 侥幸1：& 两侧都是比较运算符，结果要么为真，要么为假，所以按位与和逻辑与的结果一致；
  // 侥幸2：C 语言中数组的上界是存在的（但访问它的值是未定义的）
  ```

## 3.9 整数溢出

- 整数运算分为：有符号运算和无符号运算
  - 无符号运算没有“溢出”一说
  - 如果一个操作数是有符号整数，另一个是无符号整数，那么运算前会先把有符号整数转换为无符号整数
  - > 也就是说，只有当两个操作数都是有符号整数时，才会“溢出”
- 如果“溢出”，结果是未定义的
- 示例
  ```C
  // 一种错误的检测溢出的方式
  if (a + b < 0) complain();
  
  // 一种正确的检测溢出的方式
  if ((unsigned)a + (unsigned)b > INT_MAX) complain();
  // 另一种正确的检测溢出的方式
  if (a > INT_MAX - b) complain();
  ```

## 3.10 为函数main提供返回值

- 函数 main 与其他任何函数一样，如果并未显式声明返回类型，那么函数返回类型就默认为整型
- 通常情况下，操作系统通过 main 函数返回值判断程序是否执行成功（0：成功；其他：失败）
