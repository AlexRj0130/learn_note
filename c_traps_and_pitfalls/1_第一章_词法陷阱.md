[TOC]

# 第一章 词法陷阱

## 1.1 = 不同于 ==

- 与比较运算相比，赋值运算出现的更加频繁，因此字符数较少的符号 = 就被赋予了更常用的含义 -- 赋值操作；
- 在 C 语言中，赋值操作符号 = 被作为一种操作符对待，因而可以容易的重复进行赋值操作（如 a=b=c）；
- 如果把 = 误写为 ==，或者把 == 误写位 =，可能导致非常隐蔽的错误。虽然有些编译器可能会针对这种情况发出警告，但是不是所有编译器都是如此，因此程序员不能依赖于此。

## 1.2 & 和 | 不同于 && 和 ||

（如题所述）

## 1.3 词法分析中的 “贪心法”

- 只有一个字符长的符号，称为单字符符号；
- 包含多个字符的符号，称为多字符符号；
- 除了字符串与字符常量，符号的中间==不能嵌有空白==（空格符、制表符、换行符）；
- 如果一个单字符符号是一个多字符符号的子集，并且位于多字符符号的开始部分，则在词法分析时使用 “==贪心法==”（每个符号应该包含尽可能多的字符）进行处理。

- 补充：老版本编译器中把 +=, -=, *=, /= 写作 =+， =-， =*， =/
  - 对于 a=/*b; 老版本编译器的处理方式等价于 a =/ *b; 新版本编译器会将 /\* 识别为注释的开始符号;
  - 对于 a=-1; 老版本编译器的处理方式等价于 a = a - 1; 新版本编译器的处理方式等价于 a = -1。

## 1.4 整型常量

- 八进制整型常量以 0 开始；
- 许多 C 编译器会把 8 和 9 也作为八进制数字处理（ANSI C 禁止这种用法，因为正常的八进制数应该只包含 0~7 八个字符）；
- 有时候，为了在上下文中实现格式对齐的需要，可能会==无意中将十进制数写成八进制==的形式（通过在整型常量前添加 0 的方式实现格式对齐）。

## 1.5 字符与字符串

- 在 C 语言中，单引号和双引号含义迥异：
  - 用单引号引起的一个字符实际上代表的是一个==整数==（编译器实现）；
  - 用双引号引起的字符串，代表的是一个==指向无名数组起始字符的指针==，该数组被双引号之间的字符以及一个额外的二进制值为零的字符 '\0' 初始化。

> 可以想见，一种编程语言支持的各种数据类型都是编译器层面的。编译器结合处理器能够支持的指令生成处理各种类型数据的汇编代码。