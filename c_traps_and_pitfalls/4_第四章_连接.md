[TOC]

# 第四章 连接

- 编译器每次只处理一个文件
- 连接器是独立于 C 语言实现的
- 如果能够找到诸如 lint 的程序，就一定要善加利用


## 4.1 什么是连接器

- C 语言中的一个重要思想就是分别编译
  - 编译器负责把 C 源程序 “翻译” 成对连接器有意义的形式
- 连接器并不理解 C 语言
  - 连接器可以理解机器语言和内存布局
  - 连接器通常把目标模块看成是由一组外部对象组成的
  - 大多数连接器都禁止同一个载入模块中的两个不同外部对象拥有相同的名称
  - 处理命名冲突的最简单办法就是完全禁止
  - 连接器需要处理目标模块中对其他模块中的外部对象的引用

## 4.2 声明与定义

- int a;
  - 如果出现在所有的函数体之外，那么就是对外部对象 a 的定义，默认初始值为 0;
- int a = 7;
  - 声明并定义变量 a，分配内存并指定初值为 7；
- extern int a;
  - 说明 a 的存储空间实在程序的其他地方分配的；
  - 从连接器的角度来看，该变量时对外部变量 a 的引用，而不是定义。

## 4.3 命名冲突与 static 修饰符

- 默认情况下，两个==具有相同名称==的==外部对象==实际上代表的是==同一个对象==
- ANSI C 定义了 C 标准库函数，列出了经常用到因而可能会引发命名冲突的所有函数
- static 修饰符可以用来减少命名冲突
  - static int a;  // 用 static 修饰全局变量
  - 将 a 的作用域限制在一个源文件内（对其它源文件，a 是不可见的）
  - static 也可以用来修饰函数
  - 结论：如果一个变量或函数仅仅被同一个源文件中的其他函数使用或调用，那么为了避免可能出现的命名冲突，应该把他们声明为 static 的。

## 4.4 形参、实参与返回值

- 任何 C 函数都有一个==形参==列表
  - 列表中的每个参数都是一个变量，该==变量在函数调用过程中被初始化==
  - 如果一个函数的形参列表为空，那么该函数被调用时的实参列表也为空
  - 可见，
    - 实参：调用函数时的实际对象
    - 形参：函数定义时的占位符
- 任何一个 C 函数都有返回类型
  - 如果任何一个函数在调用它的每个文件中，都在第一次被调用之前进行了声明或定义，那么就不会有任何与返回类型相关的麻烦（头文件存在的意义）

## 4.5 检查外部类型

- 要保证一个特定名称的==所有外部定义==在每个目标模块中都有==相同的类型==，并且，“相同的类型”应该是严格意义上的相同
- 示例
  ```C
  // 错误示例1：结果不可预期
  extern int n;  // 文件1中的声明
  long n;  // 文件2中的声明（与定义）

  // 错误示例2：内存布局不一致，二者无法共存
  char filename[] = "/etc/passwd";  // 文件1中的定义
  extern char * filename;  // 文件2中的声明

  // 正确示例1：
  char filename[] = "/etc/passwd";  // 文件1中的定义
  extern char filename[];  // 文件2中的声明

  // 正确示例2：
  char * filename = "/etc/passwd";  // 文件1中的定义
  extern char * filename;  // 文件2中的声明
  ```

## 4.6 头文件

- 关于外部对象声明的问题
  - 每个外部对象只在一个地方声明，即一个头文件中
  - ==所有用到该外部对象的模块==都应该包括这个头文件
  - 定义该外部对象的模块也应该包括这个头文件
- > 预处理器会把被引用头文件中的内容原地展开



  