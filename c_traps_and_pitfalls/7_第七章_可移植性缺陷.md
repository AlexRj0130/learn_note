[TOC]

# 第七章 可移植性缺陷

- C 程序能够方便地在不同的编程环境中移植
- 但是，由于 C 语言的实现比较多，各个实现之间或多或少存在着细微的差别
- 并且，不同机器上的 C 语言的实现也有细微的差别
- 本章讨论可移植性相关的几个常见错误，重点在语言的属性上（而不是函数库）


## 7.1 应对 C 语言标准变更

- 语言标准在不断更新
- 程序的生命周期往往超过编程者最初的预料
- 如果为了增加移植性，让过去的程序能够继续工作，可能就需要放弃新特性带来的收益
- > 处理这种问题，必须慎重对待，仔细权衡

## 7.2 标识符名称的限制

- ANSI C 标准要求：C 实现必须能够去区别出前 6 个字符不同的外部名称（要求很松）
  - 一些 C 实现会把标识符中所有字符作为有效字符处理
  - 一些 C 实现会自动截断长标识符名称的尾部
  - 连接器也会对它们能够处理的名称强加限制（例如外部名称只允许使用大写字母）
- 因此，要谨慎的选择标识符的名称

## 7.3 整数的大小

- C 语言对各种不同类型的整数的相对长度作了一些（宽松）的规定
  - sizeof(short) <= sizeof(int) <= sizeof(long)
- 因此，确保可移植性的最佳办法就是使用 typedef 定义新的类型，例如
  ```C
  typedef signed char INT8
  typedef signed short INT16
  typedef signed int INT32
  typedef signed long INT64
  typedef unsigned char UINT8
  typedef unsigned short UINT16
  typedef unsigned int UINT32
  typedef unsigned long UINT64
  ```

## 7.4 字符是有符号整数还是无符号整数

- 大多数现代 C 编译器都把字符时限为 8 位整数
- 考虑一种情况：编译器将 char 转换为 int 类型时需要做出选择
  - 如果 char 是无符号整数，多余位补 0 即可
  - 如果 char 是有符号整数，则需要复制符号位
- 结论：应该明确使用的是 `signed char` 还是 `unsigned char`
- 补充：一个错误认识
  - 如果 c 是 char 类型
  - 那么强制类型转换时 (unsigned int) c，会先把 c 转换为 int 型整数，再转换为无符号 int（而不是直觉上的直接转换为无符号 int）
  
## 7.5 移位运算符

- 移位操作时的两个问题
  - 向右移位时，空出的位是由 0 填充，还是由符号位的副本填充？
    - 对于无符号数：空位由 0 填充；
    - 对于有符号数：取决于 C 语言的实现。
  - 移位计数允许的取值范围是什么？
    - 如果被移位的对象的长度是 n 位，那么取值范围为 [0 ~ n)
- 补充：
  ```C
  // 如果 low+high 的值非负，那么
  mid = (low+high) >> 1
  // 等价于
  mid = (low+high) / 2
  // 且前一个表达式的执行速度快得多
  ```

## 7.6 内存位置0

- null 指针
  - 不指向任何对象
  - 可以用于赋值和比较运算
  - 不允许其他任何形式的使用方式
- 解引用 null 指针的行为是不确定的（依赖于具体的 C 语言实现）
  - 可能直接导致程序终止执行
  - 也可能读取到垃圾信息

## 7.7 除法运算时发生的截断

- 对于除法运算和取余运算
  ```C
  q = a / b;
  r = a % b;
  ```
  - 希望在 a, b, q, r 之间维持以下关系
    1. 保证余数定义：q * b + r == a
    1. 保证除法定义：如果改变 a 的符号，则 q 的符号跟着改变，但不会改变 q 的绝对值
    1. 当 b > 0 时，希望保证 r >=0 且 r < b
- 上述 3 条不可能同时实现
  - 大多数程序设计语言（包括大多数 C 语言实现）选择放弃第 3 条（也就是余数的值可能为负）
- 示例：通过余数计算哈希
  ```C
  h = n % HASHSIZE;  // 需要确保 n 非负，最好就是 unsigned 类型

  // 否则，需要检查取余结果
  h = n % HASHSIZE;
  if (h < 0)
    h += HASHSIZE;
  ```

## 7.8 随机数的大小

- 对于不同的 C 的实现，随机数的范围可能不同，所以使用的时候要加以注意
- 附：
  - ANSI C 标准中定义了一个 RAND_MAX 常数，其值为随机数的最大值（但是早期的 C 实现中通常没有这个常数）

## 7.9 大小写转换

- toupper 和 topower 的两个版本
  - 函数版本：会对原始字符进行范围检查，但效率较低
    ```C
    int toupper(int c)
    {
        if (c >= 'a' && c <= 'z')
            return c + 'A' - 'a';
        return c;
    }
    ```
  - 宏定义版本：代码效率高，但不会对原始字符进行范围检查
    ```C
    #define _toupper(c) ((c)+'A'-'a')
    #define _tolower(c) ((c)+'a'-'A')
    ```

## 7.10 首先释放，然后重新分配

- 大多数 C 语言都提供了内存分配函数：malloc、realloc、free
- 一般情况下，调用 realloc 函数时，需要把指向一块==已分配内存的区域指针==以及这块内存的新的大小作为参数传入
  - 这个过程中有可能涉及到内存的拷贝
- 例外情况：UNIX系统参考手册第 7 版
  - 允许在某内存块被释放后重新分配其大小，前提是 realloc 函数执行的够早
  - 示例
    ```C
    // 示例1
    free(p);
    p = realloc(p, newsize);

    // 示例2：释放链表中的所有元素
    for (p = head; p != NULL; p = p->next)
        free((char *) p)
    ```
  - ==注：不推荐这样做==

## 7.11 可移植性问题的一个例子

- 努力提高软件的可移植性，实际上是延长了软件的生命期
- 可移植性的工作，大多是确保边界条件的正确